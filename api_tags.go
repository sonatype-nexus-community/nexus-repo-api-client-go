/*
Nexus Repository Manager REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.67.1-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sonatyperepo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TagsAPIService TagsAPI service
type TagsAPIService service

type ApiAssociateRequest struct {
	ctx context.Context
	ApiService *TagsAPIService
	tagName string
	wait *bool
	q *string
	repository *string
	format *string
	group *string
	name *string
	version *string
	prerelease *string
	md5 *string
	sha1 *string
	sha256 *string
	sha512 *string
	conanBaseVersion *string
	conanChannel *string
	conanRevision *string
	conanPackageId *string
	conanPackageRevision *string
	dockerImageName *string
	dockerImageTag *string
	dockerLayerId *string
	dockerContentDigest *string
	mavenGroupId *string
	mavenArtifactId *string
	mavenBaseVersion *string
	mavenExtension *string
	mavenClassifier *string
	gavec *string
	npmScope *string
	npmAuthor *string
	npmDescription *string
	npmKeywords *string
	npmLicense *string
	npmTaggedIs *string
	npmTaggedNot *string
	nugetId *string
	nugetTags *string
	nugetTitle *string
	nugetAuthors *string
	nugetDescription *string
	nugetSummary *string
	p2PluginName *string
	pypiClassifiers *string
	pypiDescription *string
	pypiKeywords *string
	pypiSummary *string
	rubygemsDescription *string
	rubygemsPlatform *string
	rubygemsSummary *string
	tag *string
	yumArchitecture *string
	yumName *string
}

// The query waits until the indexing is complete
func (r ApiAssociateRequest) Wait(wait bool) ApiAssociateRequest {
	r.wait = &wait
	return r
}

// Query by keyword
func (r ApiAssociateRequest) Q(q string) ApiAssociateRequest {
	r.q = &q
	return r
}

// Repository name
func (r ApiAssociateRequest) Repository(repository string) ApiAssociateRequest {
	r.repository = &repository
	return r
}

// Query by format
func (r ApiAssociateRequest) Format(format string) ApiAssociateRequest {
	r.format = &format
	return r
}

// Component group
func (r ApiAssociateRequest) Group(group string) ApiAssociateRequest {
	r.group = &group
	return r
}

// Component name
func (r ApiAssociateRequest) Name(name string) ApiAssociateRequest {
	r.name = &name
	return r
}

// Component version
func (r ApiAssociateRequest) Version(version string) ApiAssociateRequest {
	r.version = &version
	return r
}

// Prerelease version flag
func (r ApiAssociateRequest) Prerelease(prerelease string) ApiAssociateRequest {
	r.prerelease = &prerelease
	return r
}

// Specific MD5 hash of component&#39;s asset
func (r ApiAssociateRequest) Md5(md5 string) ApiAssociateRequest {
	r.md5 = &md5
	return r
}

// Specific SHA-1 hash of component&#39;s asset
func (r ApiAssociateRequest) Sha1(sha1 string) ApiAssociateRequest {
	r.sha1 = &sha1
	return r
}

// Specific SHA-256 hash of component&#39;s asset
func (r ApiAssociateRequest) Sha256(sha256 string) ApiAssociateRequest {
	r.sha256 = &sha256
	return r
}

// Specific SHA-512 hash of component&#39;s asset
func (r ApiAssociateRequest) Sha512(sha512 string) ApiAssociateRequest {
	r.sha512 = &sha512
	return r
}

// Conan base version
func (r ApiAssociateRequest) ConanBaseVersion(conanBaseVersion string) ApiAssociateRequest {
	r.conanBaseVersion = &conanBaseVersion
	return r
}

// Conan channel
func (r ApiAssociateRequest) ConanChannel(conanChannel string) ApiAssociateRequest {
	r.conanChannel = &conanChannel
	return r
}

// Conan recipe revision
func (r ApiAssociateRequest) ConanRevision(conanRevision string) ApiAssociateRequest {
	r.conanRevision = &conanRevision
	return r
}

// Conan package id
func (r ApiAssociateRequest) ConanPackageId(conanPackageId string) ApiAssociateRequest {
	r.conanPackageId = &conanPackageId
	return r
}

// Conan package revision
func (r ApiAssociateRequest) ConanPackageRevision(conanPackageRevision string) ApiAssociateRequest {
	r.conanPackageRevision = &conanPackageRevision
	return r
}

// Docker image name
func (r ApiAssociateRequest) DockerImageName(dockerImageName string) ApiAssociateRequest {
	r.dockerImageName = &dockerImageName
	return r
}

// Docker image tag
func (r ApiAssociateRequest) DockerImageTag(dockerImageTag string) ApiAssociateRequest {
	r.dockerImageTag = &dockerImageTag
	return r
}

// Docker layer ID
func (r ApiAssociateRequest) DockerLayerId(dockerLayerId string) ApiAssociateRequest {
	r.dockerLayerId = &dockerLayerId
	return r
}

// Docker content digest
func (r ApiAssociateRequest) DockerContentDigest(dockerContentDigest string) ApiAssociateRequest {
	r.dockerContentDigest = &dockerContentDigest
	return r
}

// Maven groupId
func (r ApiAssociateRequest) MavenGroupId(mavenGroupId string) ApiAssociateRequest {
	r.mavenGroupId = &mavenGroupId
	return r
}

// Maven artifactId
func (r ApiAssociateRequest) MavenArtifactId(mavenArtifactId string) ApiAssociateRequest {
	r.mavenArtifactId = &mavenArtifactId
	return r
}

// Maven base version
func (r ApiAssociateRequest) MavenBaseVersion(mavenBaseVersion string) ApiAssociateRequest {
	r.mavenBaseVersion = &mavenBaseVersion
	return r
}

// Maven extension of component&#39;s asset
func (r ApiAssociateRequest) MavenExtension(mavenExtension string) ApiAssociateRequest {
	r.mavenExtension = &mavenExtension
	return r
}

// Maven classifier of component&#39;s asset
func (r ApiAssociateRequest) MavenClassifier(mavenClassifier string) ApiAssociateRequest {
	r.mavenClassifier = &mavenClassifier
	return r
}

// Group asset version extension classifier
func (r ApiAssociateRequest) Gavec(gavec string) ApiAssociateRequest {
	r.gavec = &gavec
	return r
}

// npm scope
func (r ApiAssociateRequest) NpmScope(npmScope string) ApiAssociateRequest {
	r.npmScope = &npmScope
	return r
}

// npm author
func (r ApiAssociateRequest) NpmAuthor(npmAuthor string) ApiAssociateRequest {
	r.npmAuthor = &npmAuthor
	return r
}

// npm description
func (r ApiAssociateRequest) NpmDescription(npmDescription string) ApiAssociateRequest {
	r.npmDescription = &npmDescription
	return r
}

// npm keywords
func (r ApiAssociateRequest) NpmKeywords(npmKeywords string) ApiAssociateRequest {
	r.npmKeywords = &npmKeywords
	return r
}

// npm license
func (r ApiAssociateRequest) NpmLicense(npmLicense string) ApiAssociateRequest {
	r.npmLicense = &npmLicense
	return r
}

// npm tagged is
func (r ApiAssociateRequest) NpmTaggedIs(npmTaggedIs string) ApiAssociateRequest {
	r.npmTaggedIs = &npmTaggedIs
	return r
}

// npm tagged not
func (r ApiAssociateRequest) NpmTaggedNot(npmTaggedNot string) ApiAssociateRequest {
	r.npmTaggedNot = &npmTaggedNot
	return r
}

// NuGet id
func (r ApiAssociateRequest) NugetId(nugetId string) ApiAssociateRequest {
	r.nugetId = &nugetId
	return r
}

// NuGet tags
func (r ApiAssociateRequest) NugetTags(nugetTags string) ApiAssociateRequest {
	r.nugetTags = &nugetTags
	return r
}

// NuGet title
func (r ApiAssociateRequest) NugetTitle(nugetTitle string) ApiAssociateRequest {
	r.nugetTitle = &nugetTitle
	return r
}

// NuGet authors
func (r ApiAssociateRequest) NugetAuthors(nugetAuthors string) ApiAssociateRequest {
	r.nugetAuthors = &nugetAuthors
	return r
}

// NuGet description
func (r ApiAssociateRequest) NugetDescription(nugetDescription string) ApiAssociateRequest {
	r.nugetDescription = &nugetDescription
	return r
}

// NuGet summary
func (r ApiAssociateRequest) NugetSummary(nugetSummary string) ApiAssociateRequest {
	r.nugetSummary = &nugetSummary
	return r
}

// p2 plugin name
func (r ApiAssociateRequest) P2PluginName(p2PluginName string) ApiAssociateRequest {
	r.p2PluginName = &p2PluginName
	return r
}

// PyPI classifiers
func (r ApiAssociateRequest) PypiClassifiers(pypiClassifiers string) ApiAssociateRequest {
	r.pypiClassifiers = &pypiClassifiers
	return r
}

// PyPI description
func (r ApiAssociateRequest) PypiDescription(pypiDescription string) ApiAssociateRequest {
	r.pypiDescription = &pypiDescription
	return r
}

// PyPI keywords
func (r ApiAssociateRequest) PypiKeywords(pypiKeywords string) ApiAssociateRequest {
	r.pypiKeywords = &pypiKeywords
	return r
}

// PyPI summary
func (r ApiAssociateRequest) PypiSummary(pypiSummary string) ApiAssociateRequest {
	r.pypiSummary = &pypiSummary
	return r
}

// RubyGems description
func (r ApiAssociateRequest) RubygemsDescription(rubygemsDescription string) ApiAssociateRequest {
	r.rubygemsDescription = &rubygemsDescription
	return r
}

// RubyGems platform
func (r ApiAssociateRequest) RubygemsPlatform(rubygemsPlatform string) ApiAssociateRequest {
	r.rubygemsPlatform = &rubygemsPlatform
	return r
}

// RubyGems summary
func (r ApiAssociateRequest) RubygemsSummary(rubygemsSummary string) ApiAssociateRequest {
	r.rubygemsSummary = &rubygemsSummary
	return r
}

// Component tag
func (r ApiAssociateRequest) Tag(tag string) ApiAssociateRequest {
	r.tag = &tag
	return r
}

// Yum architecture
func (r ApiAssociateRequest) YumArchitecture(yumArchitecture string) ApiAssociateRequest {
	r.yumArchitecture = &yumArchitecture
	return r
}

// Yum package name
func (r ApiAssociateRequest) YumName(yumName string) ApiAssociateRequest {
	r.yumName = &yumName
	return r
}

func (r ApiAssociateRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssociateExecute(r)
}

/*
Associate Associate components with a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagName Tag to associate to the matched components
 @return ApiAssociateRequest
*/
func (a *TagsAPIService) Associate(ctx context.Context, tagName string) ApiAssociateRequest {
	return ApiAssociateRequest{
		ApiService: a,
		ctx: ctx,
		tagName: tagName,
	}
}

// Execute executes the request
func (a *TagsAPIService) AssociateExecute(r ApiAssociateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIService.Associate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tags/associate/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", url.PathEscape(parameterValueToString(r.tagName, "tagName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.wait != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "")
	} else {
		var defaultValue bool = true
		r.wait = &defaultValue
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.repository != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "repository", r.repository, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.prerelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prerelease", r.prerelease, "")
	}
	if r.md5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "md5", r.md5, "")
	}
	if r.sha1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sha1", r.sha1, "")
	}
	if r.sha256 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sha256", r.sha256, "")
	}
	if r.sha512 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sha512", r.sha512, "")
	}
	if r.conanBaseVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.baseVersion", r.conanBaseVersion, "")
	}
	if r.conanChannel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.channel", r.conanChannel, "")
	}
	if r.conanRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.revision", r.conanRevision, "")
	}
	if r.conanPackageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.packageId", r.conanPackageId, "")
	}
	if r.conanPackageRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.packageRevision", r.conanPackageRevision, "")
	}
	if r.dockerImageName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docker.imageName", r.dockerImageName, "")
	}
	if r.dockerImageTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docker.imageTag", r.dockerImageTag, "")
	}
	if r.dockerLayerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docker.layerId", r.dockerLayerId, "")
	}
	if r.dockerContentDigest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docker.contentDigest", r.dockerContentDigest, "")
	}
	if r.mavenGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.groupId", r.mavenGroupId, "")
	}
	if r.mavenArtifactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.artifactId", r.mavenArtifactId, "")
	}
	if r.mavenBaseVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.baseVersion", r.mavenBaseVersion, "")
	}
	if r.mavenExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.extension", r.mavenExtension, "")
	}
	if r.mavenClassifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.classifier", r.mavenClassifier, "")
	}
	if r.gavec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gavec", r.gavec, "")
	}
	if r.npmScope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.scope", r.npmScope, "")
	}
	if r.npmAuthor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.author", r.npmAuthor, "")
	}
	if r.npmDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.description", r.npmDescription, "")
	}
	if r.npmKeywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.keywords", r.npmKeywords, "")
	}
	if r.npmLicense != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.license", r.npmLicense, "")
	}
	if r.npmTaggedIs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.tagged_is", r.npmTaggedIs, "")
	}
	if r.npmTaggedNot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.tagged_not", r.npmTaggedNot, "")
	}
	if r.nugetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.id", r.nugetId, "")
	}
	if r.nugetTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.tags", r.nugetTags, "")
	}
	if r.nugetTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.title", r.nugetTitle, "")
	}
	if r.nugetAuthors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.authors", r.nugetAuthors, "")
	}
	if r.nugetDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.description", r.nugetDescription, "")
	}
	if r.nugetSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.summary", r.nugetSummary, "")
	}
	if r.p2PluginName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "p2.pluginName", r.p2PluginName, "")
	}
	if r.pypiClassifiers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pypi.classifiers", r.pypiClassifiers, "")
	}
	if r.pypiDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pypi.description", r.pypiDescription, "")
	}
	if r.pypiKeywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pypi.keywords", r.pypiKeywords, "")
	}
	if r.pypiSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pypi.summary", r.pypiSummary, "")
	}
	if r.rubygemsDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rubygems.description", r.rubygemsDescription, "")
	}
	if r.rubygemsPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rubygems.platform", r.rubygemsPlatform, "")
	}
	if r.rubygemsSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rubygems.summary", r.rubygemsSummary, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "")
	}
	if r.yumArchitecture != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "yum.architecture", r.yumArchitecture, "")
	}
	if r.yumName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "yum.name", r.yumName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreate1Request struct {
	ctx context.Context
	ApiService *TagsAPIService
	body *TagXO
}

func (r ApiCreate1Request) Body(body TagXO) ApiCreate1Request {
	r.body = &body
	return r
}

func (r ApiCreate1Request) Execute() (*http.Response, error) {
	return r.ApiService.Create1Execute(r)
}

/*
Create1 Create a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreate1Request
*/
func (a *TagsAPIService) Create1(ctx context.Context) ApiCreate1Request {
	return ApiCreate1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TagsAPIService) Create1Execute(r ApiCreate1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIService.Create1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDelete2Request struct {
	ctx context.Context
	ApiService *TagsAPIService
	name string
}

func (r ApiDelete2Request) Execute() (*http.Response, error) {
	return r.ApiService.Delete2Execute(r)
}

/*
Delete2 Delete a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to delete
 @return ApiDelete2Request
*/
func (a *TagsAPIService) Delete2(ctx context.Context, name string) ApiDelete2Request {
	return ApiDelete2Request{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *TagsAPIService) Delete2Execute(r ApiDelete2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIService.Delete2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisassociateRequest struct {
	ctx context.Context
	ApiService *TagsAPIService
	tagName string
	q *string
	repository *string
	format *string
	group *string
	name *string
	version *string
	prerelease *string
	md5 *string
	sha1 *string
	sha256 *string
	sha512 *string
	conanBaseVersion *string
	conanChannel *string
	conanRevision *string
	conanPackageId *string
	conanPackageRevision *string
	dockerImageName *string
	dockerImageTag *string
	dockerLayerId *string
	dockerContentDigest *string
	mavenGroupId *string
	mavenArtifactId *string
	mavenBaseVersion *string
	mavenExtension *string
	mavenClassifier *string
	gavec *string
	npmScope *string
	npmAuthor *string
	npmDescription *string
	npmKeywords *string
	npmLicense *string
	npmTaggedIs *string
	npmTaggedNot *string
	nugetId *string
	nugetTags *string
	nugetTitle *string
	nugetAuthors *string
	nugetDescription *string
	nugetSummary *string
	p2PluginName *string
	pypiClassifiers *string
	pypiDescription *string
	pypiKeywords *string
	pypiSummary *string
	rubygemsDescription *string
	rubygemsPlatform *string
	rubygemsSummary *string
	tag *string
	yumArchitecture *string
	yumName *string
}

// Query by keyword
func (r ApiDisassociateRequest) Q(q string) ApiDisassociateRequest {
	r.q = &q
	return r
}

// Repository name
func (r ApiDisassociateRequest) Repository(repository string) ApiDisassociateRequest {
	r.repository = &repository
	return r
}

// Query by format
func (r ApiDisassociateRequest) Format(format string) ApiDisassociateRequest {
	r.format = &format
	return r
}

// Component group
func (r ApiDisassociateRequest) Group(group string) ApiDisassociateRequest {
	r.group = &group
	return r
}

// Component name
func (r ApiDisassociateRequest) Name(name string) ApiDisassociateRequest {
	r.name = &name
	return r
}

// Component version
func (r ApiDisassociateRequest) Version(version string) ApiDisassociateRequest {
	r.version = &version
	return r
}

// Prerelease version flag
func (r ApiDisassociateRequest) Prerelease(prerelease string) ApiDisassociateRequest {
	r.prerelease = &prerelease
	return r
}

// Specific MD5 hash of component&#39;s asset
func (r ApiDisassociateRequest) Md5(md5 string) ApiDisassociateRequest {
	r.md5 = &md5
	return r
}

// Specific SHA-1 hash of component&#39;s asset
func (r ApiDisassociateRequest) Sha1(sha1 string) ApiDisassociateRequest {
	r.sha1 = &sha1
	return r
}

// Specific SHA-256 hash of component&#39;s asset
func (r ApiDisassociateRequest) Sha256(sha256 string) ApiDisassociateRequest {
	r.sha256 = &sha256
	return r
}

// Specific SHA-512 hash of component&#39;s asset
func (r ApiDisassociateRequest) Sha512(sha512 string) ApiDisassociateRequest {
	r.sha512 = &sha512
	return r
}

// Conan base version
func (r ApiDisassociateRequest) ConanBaseVersion(conanBaseVersion string) ApiDisassociateRequest {
	r.conanBaseVersion = &conanBaseVersion
	return r
}

// Conan channel
func (r ApiDisassociateRequest) ConanChannel(conanChannel string) ApiDisassociateRequest {
	r.conanChannel = &conanChannel
	return r
}

// Conan recipe revision
func (r ApiDisassociateRequest) ConanRevision(conanRevision string) ApiDisassociateRequest {
	r.conanRevision = &conanRevision
	return r
}

// Conan package id
func (r ApiDisassociateRequest) ConanPackageId(conanPackageId string) ApiDisassociateRequest {
	r.conanPackageId = &conanPackageId
	return r
}

// Conan package revision
func (r ApiDisassociateRequest) ConanPackageRevision(conanPackageRevision string) ApiDisassociateRequest {
	r.conanPackageRevision = &conanPackageRevision
	return r
}

// Docker image name
func (r ApiDisassociateRequest) DockerImageName(dockerImageName string) ApiDisassociateRequest {
	r.dockerImageName = &dockerImageName
	return r
}

// Docker image tag
func (r ApiDisassociateRequest) DockerImageTag(dockerImageTag string) ApiDisassociateRequest {
	r.dockerImageTag = &dockerImageTag
	return r
}

// Docker layer ID
func (r ApiDisassociateRequest) DockerLayerId(dockerLayerId string) ApiDisassociateRequest {
	r.dockerLayerId = &dockerLayerId
	return r
}

// Docker content digest
func (r ApiDisassociateRequest) DockerContentDigest(dockerContentDigest string) ApiDisassociateRequest {
	r.dockerContentDigest = &dockerContentDigest
	return r
}

// Maven groupId
func (r ApiDisassociateRequest) MavenGroupId(mavenGroupId string) ApiDisassociateRequest {
	r.mavenGroupId = &mavenGroupId
	return r
}

// Maven artifactId
func (r ApiDisassociateRequest) MavenArtifactId(mavenArtifactId string) ApiDisassociateRequest {
	r.mavenArtifactId = &mavenArtifactId
	return r
}

// Maven base version
func (r ApiDisassociateRequest) MavenBaseVersion(mavenBaseVersion string) ApiDisassociateRequest {
	r.mavenBaseVersion = &mavenBaseVersion
	return r
}

// Maven extension of component&#39;s asset
func (r ApiDisassociateRequest) MavenExtension(mavenExtension string) ApiDisassociateRequest {
	r.mavenExtension = &mavenExtension
	return r
}

// Maven classifier of component&#39;s asset
func (r ApiDisassociateRequest) MavenClassifier(mavenClassifier string) ApiDisassociateRequest {
	r.mavenClassifier = &mavenClassifier
	return r
}

// Group asset version extension classifier
func (r ApiDisassociateRequest) Gavec(gavec string) ApiDisassociateRequest {
	r.gavec = &gavec
	return r
}

// npm scope
func (r ApiDisassociateRequest) NpmScope(npmScope string) ApiDisassociateRequest {
	r.npmScope = &npmScope
	return r
}

// npm author
func (r ApiDisassociateRequest) NpmAuthor(npmAuthor string) ApiDisassociateRequest {
	r.npmAuthor = &npmAuthor
	return r
}

// npm description
func (r ApiDisassociateRequest) NpmDescription(npmDescription string) ApiDisassociateRequest {
	r.npmDescription = &npmDescription
	return r
}

// npm keywords
func (r ApiDisassociateRequest) NpmKeywords(npmKeywords string) ApiDisassociateRequest {
	r.npmKeywords = &npmKeywords
	return r
}

// npm license
func (r ApiDisassociateRequest) NpmLicense(npmLicense string) ApiDisassociateRequest {
	r.npmLicense = &npmLicense
	return r
}

// npm tagged is
func (r ApiDisassociateRequest) NpmTaggedIs(npmTaggedIs string) ApiDisassociateRequest {
	r.npmTaggedIs = &npmTaggedIs
	return r
}

// npm tagged not
func (r ApiDisassociateRequest) NpmTaggedNot(npmTaggedNot string) ApiDisassociateRequest {
	r.npmTaggedNot = &npmTaggedNot
	return r
}

// NuGet id
func (r ApiDisassociateRequest) NugetId(nugetId string) ApiDisassociateRequest {
	r.nugetId = &nugetId
	return r
}

// NuGet tags
func (r ApiDisassociateRequest) NugetTags(nugetTags string) ApiDisassociateRequest {
	r.nugetTags = &nugetTags
	return r
}

// NuGet title
func (r ApiDisassociateRequest) NugetTitle(nugetTitle string) ApiDisassociateRequest {
	r.nugetTitle = &nugetTitle
	return r
}

// NuGet authors
func (r ApiDisassociateRequest) NugetAuthors(nugetAuthors string) ApiDisassociateRequest {
	r.nugetAuthors = &nugetAuthors
	return r
}

// NuGet description
func (r ApiDisassociateRequest) NugetDescription(nugetDescription string) ApiDisassociateRequest {
	r.nugetDescription = &nugetDescription
	return r
}

// NuGet summary
func (r ApiDisassociateRequest) NugetSummary(nugetSummary string) ApiDisassociateRequest {
	r.nugetSummary = &nugetSummary
	return r
}

// p2 plugin name
func (r ApiDisassociateRequest) P2PluginName(p2PluginName string) ApiDisassociateRequest {
	r.p2PluginName = &p2PluginName
	return r
}

// PyPI classifiers
func (r ApiDisassociateRequest) PypiClassifiers(pypiClassifiers string) ApiDisassociateRequest {
	r.pypiClassifiers = &pypiClassifiers
	return r
}

// PyPI description
func (r ApiDisassociateRequest) PypiDescription(pypiDescription string) ApiDisassociateRequest {
	r.pypiDescription = &pypiDescription
	return r
}

// PyPI keywords
func (r ApiDisassociateRequest) PypiKeywords(pypiKeywords string) ApiDisassociateRequest {
	r.pypiKeywords = &pypiKeywords
	return r
}

// PyPI summary
func (r ApiDisassociateRequest) PypiSummary(pypiSummary string) ApiDisassociateRequest {
	r.pypiSummary = &pypiSummary
	return r
}

// RubyGems description
func (r ApiDisassociateRequest) RubygemsDescription(rubygemsDescription string) ApiDisassociateRequest {
	r.rubygemsDescription = &rubygemsDescription
	return r
}

// RubyGems platform
func (r ApiDisassociateRequest) RubygemsPlatform(rubygemsPlatform string) ApiDisassociateRequest {
	r.rubygemsPlatform = &rubygemsPlatform
	return r
}

// RubyGems summary
func (r ApiDisassociateRequest) RubygemsSummary(rubygemsSummary string) ApiDisassociateRequest {
	r.rubygemsSummary = &rubygemsSummary
	return r
}

// Component tag
func (r ApiDisassociateRequest) Tag(tag string) ApiDisassociateRequest {
	r.tag = &tag
	return r
}

// Yum architecture
func (r ApiDisassociateRequest) YumArchitecture(yumArchitecture string) ApiDisassociateRequest {
	r.yumArchitecture = &yumArchitecture
	return r
}

// Yum package name
func (r ApiDisassociateRequest) YumName(yumName string) ApiDisassociateRequest {
	r.yumName = &yumName
	return r
}

func (r ApiDisassociateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisassociateExecute(r)
}

/*
Disassociate Disassociate components from a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagName Tag to associate to the matched components
 @return ApiDisassociateRequest
*/
func (a *TagsAPIService) Disassociate(ctx context.Context, tagName string) ApiDisassociateRequest {
	return ApiDisassociateRequest{
		ApiService: a,
		ctx: ctx,
		tagName: tagName,
	}
}

// Execute executes the request
func (a *TagsAPIService) DisassociateExecute(r ApiDisassociateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIService.Disassociate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tags/associate/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", url.PathEscape(parameterValueToString(r.tagName, "tagName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.repository != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "repository", r.repository, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.prerelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prerelease", r.prerelease, "")
	}
	if r.md5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "md5", r.md5, "")
	}
	if r.sha1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sha1", r.sha1, "")
	}
	if r.sha256 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sha256", r.sha256, "")
	}
	if r.sha512 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sha512", r.sha512, "")
	}
	if r.conanBaseVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.baseVersion", r.conanBaseVersion, "")
	}
	if r.conanChannel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.channel", r.conanChannel, "")
	}
	if r.conanRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.revision", r.conanRevision, "")
	}
	if r.conanPackageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.packageId", r.conanPackageId, "")
	}
	if r.conanPackageRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conan.packageRevision", r.conanPackageRevision, "")
	}
	if r.dockerImageName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docker.imageName", r.dockerImageName, "")
	}
	if r.dockerImageTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docker.imageTag", r.dockerImageTag, "")
	}
	if r.dockerLayerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docker.layerId", r.dockerLayerId, "")
	}
	if r.dockerContentDigest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docker.contentDigest", r.dockerContentDigest, "")
	}
	if r.mavenGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.groupId", r.mavenGroupId, "")
	}
	if r.mavenArtifactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.artifactId", r.mavenArtifactId, "")
	}
	if r.mavenBaseVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.baseVersion", r.mavenBaseVersion, "")
	}
	if r.mavenExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.extension", r.mavenExtension, "")
	}
	if r.mavenClassifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maven.classifier", r.mavenClassifier, "")
	}
	if r.gavec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gavec", r.gavec, "")
	}
	if r.npmScope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.scope", r.npmScope, "")
	}
	if r.npmAuthor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.author", r.npmAuthor, "")
	}
	if r.npmDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.description", r.npmDescription, "")
	}
	if r.npmKeywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.keywords", r.npmKeywords, "")
	}
	if r.npmLicense != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.license", r.npmLicense, "")
	}
	if r.npmTaggedIs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.tagged_is", r.npmTaggedIs, "")
	}
	if r.npmTaggedNot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "npm.tagged_not", r.npmTaggedNot, "")
	}
	if r.nugetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.id", r.nugetId, "")
	}
	if r.nugetTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.tags", r.nugetTags, "")
	}
	if r.nugetTitle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.title", r.nugetTitle, "")
	}
	if r.nugetAuthors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.authors", r.nugetAuthors, "")
	}
	if r.nugetDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.description", r.nugetDescription, "")
	}
	if r.nugetSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nuget.summary", r.nugetSummary, "")
	}
	if r.p2PluginName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "p2.pluginName", r.p2PluginName, "")
	}
	if r.pypiClassifiers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pypi.classifiers", r.pypiClassifiers, "")
	}
	if r.pypiDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pypi.description", r.pypiDescription, "")
	}
	if r.pypiKeywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pypi.keywords", r.pypiKeywords, "")
	}
	if r.pypiSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pypi.summary", r.pypiSummary, "")
	}
	if r.rubygemsDescription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rubygems.description", r.rubygemsDescription, "")
	}
	if r.rubygemsPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rubygems.platform", r.rubygemsPlatform, "")
	}
	if r.rubygemsSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rubygems.summary", r.rubygemsSummary, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "")
	}
	if r.yumArchitecture != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "yum.architecture", r.yumArchitecture, "")
	}
	if r.yumName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "yum.name", r.yumName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGet3Request struct {
	ctx context.Context
	ApiService *TagsAPIService
	name string
}

func (r ApiGet3Request) Execute() (*TagXO, *http.Response, error) {
	return r.ApiService.Get3Execute(r)
}

/*
Get3 Get a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to retrieve
 @return ApiGet3Request
*/
func (a *TagsAPIService) Get3(ctx context.Context, name string) ApiGet3Request {
	return ApiGet3Request{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return TagXO
func (a *TagsAPIService) Get3Execute(r ApiGet3Request) (*TagXO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagXO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIService.Get3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagsRequest struct {
	ctx context.Context
	ApiService *TagsAPIService
	continuationToken *string
}

// A token returned by a prior request. If present, the next page of results are returned
func (r ApiGetTagsRequest) ContinuationToken(continuationToken string) ApiGetTagsRequest {
	r.continuationToken = &continuationToken
	return r
}

func (r ApiGetTagsRequest) Execute() (*PageTagXO, *http.Response, error) {
	return r.ApiService.GetTagsExecute(r)
}

/*
GetTags List tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTagsRequest
*/
func (a *TagsAPIService) GetTags(ctx context.Context) ApiGetTagsRequest {
	return ApiGetTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageTagXO
func (a *TagsAPIService) GetTagsExecute(r ApiGetTagsRequest) (*PageTagXO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageTagXO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIService.GetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.continuationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "continuationToken", r.continuationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceRequest struct {
	ctx context.Context
	ApiService *TagsAPIService
	name string
	body *BaseTagXO
}

func (r ApiReplaceRequest) Body(body BaseTagXO) ApiReplaceRequest {
	r.body = &body
	return r
}

func (r ApiReplaceRequest) Execute() (*TagXO, *http.Response, error) {
	return r.ApiService.ReplaceExecute(r)
}

/*
Replace Update a tags attributes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiReplaceRequest
*/
func (a *TagsAPIService) Replace(ctx context.Context, name string) ApiReplaceRequest {
	return ApiReplaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return TagXO
func (a *TagsAPIService) ReplaceExecute(r ApiReplaceRequest) (*TagXO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagXO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagsAPIService.Replace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
