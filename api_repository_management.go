/*
Sonatype Nexus Repository Manager

This documents the available APIs into [Sonatype Nexus Repository Manager](https://www.sonatype.com/products/sonatype-nexus-repository) as of version 3.81.1-01.

API version: 3.81.1-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v3

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RepositoryManagementAPIService RepositoryManagementAPI service
type RepositoryManagementAPIService service

type ApiCreateAptHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *AptHostedRepositoryApiRequest
}

func (r ApiCreateAptHostedRepositoryRequest) Body(body AptHostedRepositoryApiRequest) ApiCreateAptHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateAptHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateAptHostedRepositoryExecute(r)
}

/*
CreateAptHostedRepository Create APT hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAptHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateAptHostedRepository(ctx context.Context) ApiCreateAptHostedRepositoryRequest {
	return ApiCreateAptHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateAptHostedRepositoryExecute(r ApiCreateAptHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateAptHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/apt/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateAptProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *AptProxyRepositoryApiRequest
}

func (r ApiCreateAptProxyRepositoryRequest) Body(body AptProxyRepositoryApiRequest) ApiCreateAptProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateAptProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateAptProxyRepositoryExecute(r)
}

/*
CreateAptProxyRepository Create APT proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAptProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateAptProxyRepository(ctx context.Context) ApiCreateAptProxyRepositoryRequest {
	return ApiCreateAptProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateAptProxyRepositoryExecute(r ApiCreateAptProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateAptProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/apt/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCargoGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *CargoGroupRepositoryApiRequest
}

func (r ApiCreateCargoGroupRepositoryRequest) Body(body CargoGroupRepositoryApiRequest) ApiCreateCargoGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateCargoGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCargoGroupRepositoryExecute(r)
}

/*
CreateCargoGroupRepository Create cargo group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCargoGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateCargoGroupRepository(ctx context.Context) ApiCreateCargoGroupRepositoryRequest {
	return ApiCreateCargoGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateCargoGroupRepositoryExecute(r ApiCreateCargoGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateCargoGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCargoHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *CargoHostedRepositoryApiRequest
}

func (r ApiCreateCargoHostedRepositoryRequest) Body(body CargoHostedRepositoryApiRequest) ApiCreateCargoHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateCargoHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCargoHostedRepositoryExecute(r)
}

/*
CreateCargoHostedRepository Create cargo hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCargoHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateCargoHostedRepository(ctx context.Context) ApiCreateCargoHostedRepositoryRequest {
	return ApiCreateCargoHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateCargoHostedRepositoryExecute(r ApiCreateCargoHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateCargoHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCargoProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *CargoProxyRepositoryApiRequest
}

func (r ApiCreateCargoProxyRepositoryRequest) Body(body CargoProxyRepositoryApiRequest) ApiCreateCargoProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateCargoProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCargoProxyRepositoryExecute(r)
}

/*
CreateCargoProxyRepository Create cargo proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCargoProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateCargoProxyRepository(ctx context.Context) ApiCreateCargoProxyRepositoryRequest {
	return ApiCreateCargoProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateCargoProxyRepositoryExecute(r ApiCreateCargoProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateCargoProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCocoapodsProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *CocoapodsProxyRepositoryApiRequest
}

func (r ApiCreateCocoapodsProxyRepositoryRequest) Body(body CocoapodsProxyRepositoryApiRequest) ApiCreateCocoapodsProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateCocoapodsProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCocoapodsProxyRepositoryExecute(r)
}

/*
CreateCocoapodsProxyRepository Create Cocoapods proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCocoapodsProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateCocoapodsProxyRepository(ctx context.Context) ApiCreateCocoapodsProxyRepositoryRequest {
	return ApiCreateCocoapodsProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateCocoapodsProxyRepositoryExecute(r ApiCreateCocoapodsProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateCocoapodsProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cocoapods/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateComposerProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *ComposerProxyRepositoryApiRequest
}

func (r ApiCreateComposerProxyRepositoryRequest) Body(body ComposerProxyRepositoryApiRequest) ApiCreateComposerProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateComposerProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateComposerProxyRepositoryExecute(r)
}

/*
CreateComposerProxyRepository Create composer proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateComposerProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateComposerProxyRepository(ctx context.Context) ApiCreateComposerProxyRepositoryRequest {
	return ApiCreateComposerProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateComposerProxyRepositoryExecute(r ApiCreateComposerProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateComposerProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/composer/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateConanGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *ConanGroupRepositoryApiRequest
}

func (r ApiCreateConanGroupRepositoryRequest) Body(body ConanGroupRepositoryApiRequest) ApiCreateConanGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateConanGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateConanGroupRepositoryExecute(r)
}

/*
CreateConanGroupRepository Create Conan group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConanGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateConanGroupRepository(ctx context.Context) ApiCreateConanGroupRepositoryRequest {
	return ApiCreateConanGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateConanGroupRepositoryExecute(r ApiCreateConanGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateConanGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateConanHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *ConanHostedRepositoryApiRequest
}

func (r ApiCreateConanHostedRepositoryRequest) Body(body ConanHostedRepositoryApiRequest) ApiCreateConanHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateConanHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateConanHostedRepositoryExecute(r)
}

/*
CreateConanHostedRepository Create Conan hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConanHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateConanHostedRepository(ctx context.Context) ApiCreateConanHostedRepositoryRequest {
	return ApiCreateConanHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateConanHostedRepositoryExecute(r ApiCreateConanHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateConanHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateConanProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *ConanProxyRepositoryApiRequest
}

func (r ApiCreateConanProxyRepositoryRequest) Body(body ConanProxyRepositoryApiRequest) ApiCreateConanProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateConanProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateConanProxyRepositoryExecute(r)
}

/*
CreateConanProxyRepository Create Conan proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConanProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateConanProxyRepository(ctx context.Context) ApiCreateConanProxyRepositoryRequest {
	return ApiCreateConanProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateConanProxyRepositoryExecute(r ApiCreateConanProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateConanProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateCondaProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *CondaProxyRepositoryApiRequest
}

func (r ApiCreateCondaProxyRepositoryRequest) Body(body CondaProxyRepositoryApiRequest) ApiCreateCondaProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateCondaProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCondaProxyRepositoryExecute(r)
}

/*
CreateCondaProxyRepository Create conda proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCondaProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateCondaProxyRepository(ctx context.Context) ApiCreateCondaProxyRepositoryRequest {
	return ApiCreateCondaProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateCondaProxyRepositoryExecute(r ApiCreateCondaProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateCondaProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conda/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDockerGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *DockerGroupRepositoryApiRequest
}

func (r ApiCreateDockerGroupRepositoryRequest) Body(body DockerGroupRepositoryApiRequest) ApiCreateDockerGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateDockerGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDockerGroupRepositoryExecute(r)
}

/*
CreateDockerGroupRepository Create Docker group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDockerGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateDockerGroupRepository(ctx context.Context) ApiCreateDockerGroupRepositoryRequest {
	return ApiCreateDockerGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateDockerGroupRepositoryExecute(r ApiCreateDockerGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateDockerGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDockerHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *DockerHostedRepositoryApiRequest
}

func (r ApiCreateDockerHostedRepositoryRequest) Body(body DockerHostedRepositoryApiRequest) ApiCreateDockerHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateDockerHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDockerHostedRepositoryExecute(r)
}

/*
CreateDockerHostedRepository Create Docker hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDockerHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateDockerHostedRepository(ctx context.Context) ApiCreateDockerHostedRepositoryRequest {
	return ApiCreateDockerHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateDockerHostedRepositoryExecute(r ApiCreateDockerHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateDockerHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDockerProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *DockerProxyRepositoryApiRequest
}

func (r ApiCreateDockerProxyRepositoryRequest) Body(body DockerProxyRepositoryApiRequest) ApiCreateDockerProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateDockerProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDockerProxyRepositoryExecute(r)
}

/*
CreateDockerProxyRepository Create Docker proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDockerProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateDockerProxyRepository(ctx context.Context) ApiCreateDockerProxyRepositoryRequest {
	return ApiCreateDockerProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateDockerProxyRepositoryExecute(r ApiCreateDockerProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateDockerProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateGitlfsHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *GitLfsHostedRepositoryApiRequest
}

func (r ApiCreateGitlfsHostedRepositoryRequest) Body(body GitLfsHostedRepositoryApiRequest) ApiCreateGitlfsHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateGitlfsHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateGitlfsHostedRepositoryExecute(r)
}

/*
CreateGitlfsHostedRepository Create Git LFS hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGitlfsHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateGitlfsHostedRepository(ctx context.Context) ApiCreateGitlfsHostedRepositoryRequest {
	return ApiCreateGitlfsHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateGitlfsHostedRepositoryExecute(r ApiCreateGitlfsHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateGitlfsHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/gitlfs/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateGoGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *GolangGroupRepositoryApiRequest
}

func (r ApiCreateGoGroupRepositoryRequest) Body(body GolangGroupRepositoryApiRequest) ApiCreateGoGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateGoGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateGoGroupRepositoryExecute(r)
}

/*
CreateGoGroupRepository Create a Go group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGoGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateGoGroupRepository(ctx context.Context) ApiCreateGoGroupRepositoryRequest {
	return ApiCreateGoGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateGoGroupRepositoryExecute(r ApiCreateGoGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateGoGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/go/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateGoProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *GolangProxyRepositoryApiRequest
}

func (r ApiCreateGoProxyRepositoryRequest) Body(body GolangProxyRepositoryApiRequest) ApiCreateGoProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateGoProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateGoProxyRepositoryExecute(r)
}

/*
CreateGoProxyRepository Create a Go proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGoProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateGoProxyRepository(ctx context.Context) ApiCreateGoProxyRepositoryRequest {
	return ApiCreateGoProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateGoProxyRepositoryExecute(r ApiCreateGoProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateGoProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/go/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateHelmHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *HelmHostedRepositoryApiRequest
}

func (r ApiCreateHelmHostedRepositoryRequest) Body(body HelmHostedRepositoryApiRequest) ApiCreateHelmHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateHelmHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateHelmHostedRepositoryExecute(r)
}

/*
CreateHelmHostedRepository Create Helm hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateHelmHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateHelmHostedRepository(ctx context.Context) ApiCreateHelmHostedRepositoryRequest {
	return ApiCreateHelmHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateHelmHostedRepositoryExecute(r ApiCreateHelmHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateHelmHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/helm/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateHelmProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *HelmProxyRepositoryApiRequest
}

func (r ApiCreateHelmProxyRepositoryRequest) Body(body HelmProxyRepositoryApiRequest) ApiCreateHelmProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateHelmProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateHelmProxyRepositoryExecute(r)
}

/*
CreateHelmProxyRepository Create Helm proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateHelmProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateHelmProxyRepository(ctx context.Context) ApiCreateHelmProxyRepositoryRequest {
	return ApiCreateHelmProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateHelmProxyRepositoryExecute(r ApiCreateHelmProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateHelmProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/helm/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateHuggingfaceProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *HuggingFaceProxyRepositoryApiRequest
}

func (r ApiCreateHuggingfaceProxyRepositoryRequest) Body(body HuggingFaceProxyRepositoryApiRequest) ApiCreateHuggingfaceProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateHuggingfaceProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateHuggingfaceProxyRepositoryExecute(r)
}

/*
CreateHuggingfaceProxyRepository Create huggingface proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateHuggingfaceProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateHuggingfaceProxyRepository(ctx context.Context) ApiCreateHuggingfaceProxyRepositoryRequest {
	return ApiCreateHuggingfaceProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateHuggingfaceProxyRepositoryExecute(r ApiCreateHuggingfaceProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateHuggingfaceProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/huggingface/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateMavenGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *MavenGroupRepositoryApiRequest
}

func (r ApiCreateMavenGroupRepositoryRequest) Body(body MavenGroupRepositoryApiRequest) ApiCreateMavenGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateMavenGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateMavenGroupRepositoryExecute(r)
}

/*
CreateMavenGroupRepository Create Maven group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMavenGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateMavenGroupRepository(ctx context.Context) ApiCreateMavenGroupRepositoryRequest {
	return ApiCreateMavenGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateMavenGroupRepositoryExecute(r ApiCreateMavenGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateMavenGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateMavenHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *MavenHostedRepositoryApiRequest
}

func (r ApiCreateMavenHostedRepositoryRequest) Body(body MavenHostedRepositoryApiRequest) ApiCreateMavenHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateMavenHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateMavenHostedRepositoryExecute(r)
}

/*
CreateMavenHostedRepository Create Maven hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMavenHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateMavenHostedRepository(ctx context.Context) ApiCreateMavenHostedRepositoryRequest {
	return ApiCreateMavenHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateMavenHostedRepositoryExecute(r ApiCreateMavenHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateMavenHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateMavenProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *MavenProxyRepositoryApiRequest
}

func (r ApiCreateMavenProxyRepositoryRequest) Body(body MavenProxyRepositoryApiRequest) ApiCreateMavenProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateMavenProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateMavenProxyRepositoryExecute(r)
}

/*
CreateMavenProxyRepository Create Maven proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMavenProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateMavenProxyRepository(ctx context.Context) ApiCreateMavenProxyRepositoryRequest {
	return ApiCreateMavenProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateMavenProxyRepositoryExecute(r ApiCreateMavenProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateMavenProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNpmGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *NpmGroupRepositoryApiRequest
}

func (r ApiCreateNpmGroupRepositoryRequest) Body(body NpmGroupRepositoryApiRequest) ApiCreateNpmGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateNpmGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateNpmGroupRepositoryExecute(r)
}

/*
CreateNpmGroupRepository Create npm group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNpmGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateNpmGroupRepository(ctx context.Context) ApiCreateNpmGroupRepositoryRequest {
	return ApiCreateNpmGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateNpmGroupRepositoryExecute(r ApiCreateNpmGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateNpmGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNpmHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *NpmHostedRepositoryApiRequest
}

func (r ApiCreateNpmHostedRepositoryRequest) Body(body NpmHostedRepositoryApiRequest) ApiCreateNpmHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateNpmHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateNpmHostedRepositoryExecute(r)
}

/*
CreateNpmHostedRepository Create npm hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNpmHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateNpmHostedRepository(ctx context.Context) ApiCreateNpmHostedRepositoryRequest {
	return ApiCreateNpmHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateNpmHostedRepositoryExecute(r ApiCreateNpmHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateNpmHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNpmProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *NpmProxyRepositoryApiRequest
}

func (r ApiCreateNpmProxyRepositoryRequest) Body(body NpmProxyRepositoryApiRequest) ApiCreateNpmProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateNpmProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateNpmProxyRepositoryExecute(r)
}

/*
CreateNpmProxyRepository Create npm proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNpmProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateNpmProxyRepository(ctx context.Context) ApiCreateNpmProxyRepositoryRequest {
	return ApiCreateNpmProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateNpmProxyRepositoryExecute(r ApiCreateNpmProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateNpmProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNugetGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *NugetGroupRepositoryApiRequest
}

func (r ApiCreateNugetGroupRepositoryRequest) Body(body NugetGroupRepositoryApiRequest) ApiCreateNugetGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateNugetGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateNugetGroupRepositoryExecute(r)
}

/*
CreateNugetGroupRepository Create NuGet group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNugetGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateNugetGroupRepository(ctx context.Context) ApiCreateNugetGroupRepositoryRequest {
	return ApiCreateNugetGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateNugetGroupRepositoryExecute(r ApiCreateNugetGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateNugetGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNugetHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *NugetHostedRepositoryApiRequest
}

func (r ApiCreateNugetHostedRepositoryRequest) Body(body NugetHostedRepositoryApiRequest) ApiCreateNugetHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateNugetHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateNugetHostedRepositoryExecute(r)
}

/*
CreateNugetHostedRepository Create NuGet hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNugetHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateNugetHostedRepository(ctx context.Context) ApiCreateNugetHostedRepositoryRequest {
	return ApiCreateNugetHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateNugetHostedRepositoryExecute(r ApiCreateNugetHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateNugetHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNugetProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *NugetProxyRepositoryApiRequest
}

func (r ApiCreateNugetProxyRepositoryRequest) Body(body NugetProxyRepositoryApiRequest) ApiCreateNugetProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateNugetProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateNugetProxyRepositoryExecute(r)
}

/*
CreateNugetProxyRepository Create NuGet proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNugetProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateNugetProxyRepository(ctx context.Context) ApiCreateNugetProxyRepositoryRequest {
	return ApiCreateNugetProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateNugetProxyRepositoryExecute(r ApiCreateNugetProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateNugetProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateP2ProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *P2ProxyRepositoryApiRequest
}

func (r ApiCreateP2ProxyRepositoryRequest) Body(body P2ProxyRepositoryApiRequest) ApiCreateP2ProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateP2ProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateP2ProxyRepositoryExecute(r)
}

/*
CreateP2ProxyRepository Create p2 proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateP2ProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateP2ProxyRepository(ctx context.Context) ApiCreateP2ProxyRepositoryRequest {
	return ApiCreateP2ProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateP2ProxyRepositoryExecute(r ApiCreateP2ProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateP2ProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/p2/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreatePypiGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *PypiGroupRepositoryApiRequest
}

func (r ApiCreatePypiGroupRepositoryRequest) Body(body PypiGroupRepositoryApiRequest) ApiCreatePypiGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreatePypiGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreatePypiGroupRepositoryExecute(r)
}

/*
CreatePypiGroupRepository Create PyPI group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePypiGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreatePypiGroupRepository(ctx context.Context) ApiCreatePypiGroupRepositoryRequest {
	return ApiCreatePypiGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreatePypiGroupRepositoryExecute(r ApiCreatePypiGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreatePypiGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreatePypiHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *PypiHostedRepositoryApiRequest
}

func (r ApiCreatePypiHostedRepositoryRequest) Body(body PypiHostedRepositoryApiRequest) ApiCreatePypiHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreatePypiHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreatePypiHostedRepositoryExecute(r)
}

/*
CreatePypiHostedRepository Create PyPI hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePypiHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreatePypiHostedRepository(ctx context.Context) ApiCreatePypiHostedRepositoryRequest {
	return ApiCreatePypiHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreatePypiHostedRepositoryExecute(r ApiCreatePypiHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreatePypiHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreatePypiProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *PypiProxyRepositoryApiRequest
}

func (r ApiCreatePypiProxyRepositoryRequest) Body(body PypiProxyRepositoryApiRequest) ApiCreatePypiProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreatePypiProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreatePypiProxyRepositoryExecute(r)
}

/*
CreatePypiProxyRepository Create PyPI proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatePypiProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreatePypiProxyRepository(ctx context.Context) ApiCreatePypiProxyRepositoryRequest {
	return ApiCreatePypiProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreatePypiProxyRepositoryExecute(r ApiCreatePypiProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreatePypiProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RGroupRepositoryApiRequest
}

func (r ApiCreateRGroupRepositoryRequest) Body(body RGroupRepositoryApiRequest) ApiCreateRGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRGroupRepositoryExecute(r)
}

/*
CreateRGroupRepository Create R group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRGroupRepository(ctx context.Context) ApiCreateRGroupRepositoryRequest {
	return ApiCreateRGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRGroupRepositoryExecute(r ApiCreateRGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RHostedRepositoryApiRequest
}

func (r ApiCreateRHostedRepositoryRequest) Body(body RHostedRepositoryApiRequest) ApiCreateRHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRHostedRepositoryExecute(r)
}

/*
CreateRHostedRepository Create R hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRHostedRepository(ctx context.Context) ApiCreateRHostedRepositoryRequest {
	return ApiCreateRHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRHostedRepositoryExecute(r ApiCreateRHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RProxyRepositoryApiRequest
}

func (r ApiCreateRProxyRepositoryRequest) Body(body RProxyRepositoryApiRequest) ApiCreateRProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRProxyRepositoryExecute(r)
}

/*
CreateRProxyRepository Create R proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRProxyRepository(ctx context.Context) ApiCreateRProxyRepositoryRequest {
	return ApiCreateRProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRProxyRepositoryExecute(r ApiCreateRProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRawGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RawGroupRepositoryApiRequest
}

func (r ApiCreateRawGroupRepositoryRequest) Body(body RawGroupRepositoryApiRequest) ApiCreateRawGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRawGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRawGroupRepositoryExecute(r)
}

/*
CreateRawGroupRepository Create raw group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRawGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRawGroupRepository(ctx context.Context) ApiCreateRawGroupRepositoryRequest {
	return ApiCreateRawGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRawGroupRepositoryExecute(r ApiCreateRawGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRawGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRawHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RawHostedRepositoryApiRequest
}

func (r ApiCreateRawHostedRepositoryRequest) Body(body RawHostedRepositoryApiRequest) ApiCreateRawHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRawHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRawHostedRepositoryExecute(r)
}

/*
CreateRawHostedRepository Create raw hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRawHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRawHostedRepository(ctx context.Context) ApiCreateRawHostedRepositoryRequest {
	return ApiCreateRawHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRawHostedRepositoryExecute(r ApiCreateRawHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRawHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRawProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RawProxyRepositoryApiRequest
}

func (r ApiCreateRawProxyRepositoryRequest) Body(body RawProxyRepositoryApiRequest) ApiCreateRawProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRawProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRawProxyRepositoryExecute(r)
}

/*
CreateRawProxyRepository Create raw proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRawProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRawProxyRepository(ctx context.Context) ApiCreateRawProxyRepositoryRequest {
	return ApiCreateRawProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRawProxyRepositoryExecute(r ApiCreateRawProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRawProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRubygemsGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RubyGemsGroupRepositoryApiRequest
}

func (r ApiCreateRubygemsGroupRepositoryRequest) Body(body RubyGemsGroupRepositoryApiRequest) ApiCreateRubygemsGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRubygemsGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRubygemsGroupRepositoryExecute(r)
}

/*
CreateRubygemsGroupRepository Create RubyGems group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRubygemsGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRubygemsGroupRepository(ctx context.Context) ApiCreateRubygemsGroupRepositoryRequest {
	return ApiCreateRubygemsGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRubygemsGroupRepositoryExecute(r ApiCreateRubygemsGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRubygemsGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRubygemsHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RubyGemsHostedRepositoryApiRequest
}

func (r ApiCreateRubygemsHostedRepositoryRequest) Body(body RubyGemsHostedRepositoryApiRequest) ApiCreateRubygemsHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRubygemsHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRubygemsHostedRepositoryExecute(r)
}

/*
CreateRubygemsHostedRepository Create RubyGems hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRubygemsHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRubygemsHostedRepository(ctx context.Context) ApiCreateRubygemsHostedRepositoryRequest {
	return ApiCreateRubygemsHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRubygemsHostedRepositoryExecute(r ApiCreateRubygemsHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRubygemsHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateRubygemsProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *RubyGemsProxyRepositoryApiRequest
}

func (r ApiCreateRubygemsProxyRepositoryRequest) Body(body RubyGemsProxyRepositoryApiRequest) ApiCreateRubygemsProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateRubygemsProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRubygemsProxyRepositoryExecute(r)
}

/*
CreateRubygemsProxyRepository Create RubyGems proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRubygemsProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateRubygemsProxyRepository(ctx context.Context) ApiCreateRubygemsProxyRepositoryRequest {
	return ApiCreateRubygemsProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateRubygemsProxyRepositoryExecute(r ApiCreateRubygemsProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateRubygemsProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateYumGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *YumGroupRepositoryApiRequest
}

func (r ApiCreateYumGroupRepositoryRequest) Body(body YumGroupRepositoryApiRequest) ApiCreateYumGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateYumGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateYumGroupRepositoryExecute(r)
}

/*
CreateYumGroupRepository Create Yum group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateYumGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateYumGroupRepository(ctx context.Context) ApiCreateYumGroupRepositoryRequest {
	return ApiCreateYumGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateYumGroupRepositoryExecute(r ApiCreateYumGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateYumGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateYumHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *YumHostedRepositoryApiRequest
}

func (r ApiCreateYumHostedRepositoryRequest) Body(body YumHostedRepositoryApiRequest) ApiCreateYumHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateYumHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateYumHostedRepositoryExecute(r)
}

/*
CreateYumHostedRepository Create Yum hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateYumHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateYumHostedRepository(ctx context.Context) ApiCreateYumHostedRepositoryRequest {
	return ApiCreateYumHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateYumHostedRepositoryExecute(r ApiCreateYumHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateYumHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/hosted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateYumProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	body *YumProxyRepositoryApiRequest
}

func (r ApiCreateYumProxyRepositoryRequest) Body(body YumProxyRepositoryApiRequest) ApiCreateYumProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateYumProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateYumProxyRepositoryExecute(r)
}

/*
CreateYumProxyRepository Create Yum proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateYumProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreateYumProxyRepository(ctx context.Context) ApiCreateYumProxyRepositoryRequest {
	return ApiCreateYumProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreateYumProxyRepositoryExecute(r ApiCreateYumProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreateYumProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/proxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreaterepositorynameHealthCheckRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiCreaterepositorynameHealthCheckRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreaterepositorynameHealthCheckRepositoryExecute(r)
}

/*
CreaterepositorynameHealthCheckRepository Enable repository health check. Proxy repositories only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to enable Repository Health Check for
 @return ApiCreaterepositorynameHealthCheckRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreaterepositorynameHealthCheckRepository(ctx context.Context, repositoryName string) ApiCreaterepositorynameHealthCheckRepositoryRequest {
	return ApiCreaterepositorynameHealthCheckRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreaterepositorynameHealthCheckRepositoryExecute(r ApiCreaterepositorynameHealthCheckRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreaterepositorynameHealthCheckRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/{repositoryName}/health-check"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreaterepositorynameInvalidateCacheRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiCreaterepositorynameInvalidateCacheRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreaterepositorynameInvalidateCacheRepositoryExecute(r)
}

/*
CreaterepositorynameInvalidateCacheRepository Invalidate repository cache. Proxy or group repositories only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to invalidate cache
 @return ApiCreaterepositorynameInvalidateCacheRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreaterepositorynameInvalidateCacheRepository(ctx context.Context, repositoryName string) ApiCreaterepositorynameInvalidateCacheRepositoryRequest {
	return ApiCreaterepositorynameInvalidateCacheRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreaterepositorynameInvalidateCacheRepositoryExecute(r ApiCreaterepositorynameInvalidateCacheRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreaterepositorynameInvalidateCacheRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/{repositoryName}/invalidate-cache"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreaterepositorynameRebuildIndexRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiCreaterepositorynameRebuildIndexRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreaterepositorynameRebuildIndexRepositoryExecute(r)
}

/*
CreaterepositorynameRebuildIndexRepository Schedule a 'Repair - Rebuild repository search' Task. Hosted or proxy repositories only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to rebuild index
 @return ApiCreaterepositorynameRebuildIndexRepositoryRequest
*/
func (a *RepositoryManagementAPIService) CreaterepositorynameRebuildIndexRepository(ctx context.Context, repositoryName string) ApiCreaterepositorynameRebuildIndexRepositoryRequest {
	return ApiCreaterepositorynameRebuildIndexRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) CreaterepositorynameRebuildIndexRepositoryExecute(r ApiCreaterepositorynameRebuildIndexRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.CreaterepositorynameRebuildIndexRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/{repositoryName}/rebuild-index"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiDeleteRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryExecute(r)
}

/*
DeleteRepository Delete repository of any format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to delete
 @return ApiDeleteRepositoryRequest
*/
func (a *RepositoryManagementAPIService) DeleteRepository(ctx context.Context, repositoryName string) ApiDeleteRepositoryRequest {
	return ApiDeleteRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) DeleteRepositoryExecute(r ApiDeleteRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.DeleteRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableRepositoryHealthCheckRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiDisableRepositoryHealthCheckRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableRepositoryHealthCheckExecute(r)
}

/*
DisableRepositoryHealthCheck Disable repository health check. Proxy repositories only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to disable Repository Health Check for
 @return ApiDisableRepositoryHealthCheckRequest
*/
func (a *RepositoryManagementAPIService) DisableRepositoryHealthCheck(ctx context.Context, repositoryName string) ApiDisableRepositoryHealthCheckRequest {
	return ApiDisableRepositoryHealthCheckRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) DisableRepositoryHealthCheckExecute(r ApiDisableRepositoryHealthCheckRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.DisableRepositoryHealthCheck")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/{repositoryName}/health-check"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllRepositoriesRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
}

func (r ApiGetAllRepositoriesRequest) Execute() ([]RepositoryXO, *http.Response, error) {
	return r.ApiService.GetAllRepositoriesExecute(r)
}

/*
GetAllRepositories List repositories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllRepositoriesRequest
*/
func (a *RepositoryManagementAPIService) GetAllRepositories(ctx context.Context) ApiGetAllRepositoriesRequest {
	return ApiGetAllRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RepositoryXO
func (a *RepositoryManagementAPIService) GetAllRepositoriesExecute(r ApiGetAllRepositoriesRequest) ([]RepositoryXO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RepositoryXO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetAllRepositories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAptHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetAptHostedRepositoryRequest) Execute() (*AptHostedApiRepository, *http.Response, error) {
	return r.ApiService.GetAptHostedRepositoryExecute(r)
}

/*
GetAptHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetAptHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetAptHostedRepository(ctx context.Context, repositoryName string) ApiGetAptHostedRepositoryRequest {
	return ApiGetAptHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return AptHostedApiRepository
func (a *RepositoryManagementAPIService) GetAptHostedRepositoryExecute(r ApiGetAptHostedRepositoryRequest) (*AptHostedApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AptHostedApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetAptHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/apt/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAptProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetAptProxyRepositoryRequest) Execute() (*AptProxyApiRepository, *http.Response, error) {
	return r.ApiService.GetAptProxyRepositoryExecute(r)
}

/*
GetAptProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetAptProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetAptProxyRepository(ctx context.Context, repositoryName string) ApiGetAptProxyRepositoryRequest {
	return ApiGetAptProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return AptProxyApiRepository
func (a *RepositoryManagementAPIService) GetAptProxyRepositoryExecute(r ApiGetAptProxyRepositoryRequest) (*AptProxyApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AptProxyApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetAptProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/apt/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCargoGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetCargoGroupRepositoryRequest) Execute() (*CargoGroupApiRepository, *http.Response, error) {
	return r.ApiService.GetCargoGroupRepositoryExecute(r)
}

/*
GetCargoGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetCargoGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetCargoGroupRepository(ctx context.Context, repositoryName string) ApiGetCargoGroupRepositoryRequest {
	return ApiGetCargoGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return CargoGroupApiRepository
func (a *RepositoryManagementAPIService) GetCargoGroupRepositoryExecute(r ApiGetCargoGroupRepositoryRequest) (*CargoGroupApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CargoGroupApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetCargoGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCargoHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetCargoHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetCargoHostedRepositoryExecute(r)
}

/*
GetCargoHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetCargoHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetCargoHostedRepository(ctx context.Context, repositoryName string) ApiGetCargoHostedRepositoryRequest {
	return ApiGetCargoHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetCargoHostedRepositoryExecute(r ApiGetCargoHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetCargoHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCargoProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetCargoProxyRepositoryRequest) Execute() (*CargoProxyApiRepository, *http.Response, error) {
	return r.ApiService.GetCargoProxyRepositoryExecute(r)
}

/*
GetCargoProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetCargoProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetCargoProxyRepository(ctx context.Context, repositoryName string) ApiGetCargoProxyRepositoryRequest {
	return ApiGetCargoProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return CargoProxyApiRepository
func (a *RepositoryManagementAPIService) GetCargoProxyRepositoryExecute(r ApiGetCargoProxyRepositoryRequest) (*CargoProxyApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CargoProxyApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetCargoProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCocoapodsProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetCocoapodsProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetCocoapodsProxyRepositoryExecute(r)
}

/*
GetCocoapodsProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetCocoapodsProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetCocoapodsProxyRepository(ctx context.Context, repositoryName string) ApiGetCocoapodsProxyRepositoryRequest {
	return ApiGetCocoapodsProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetCocoapodsProxyRepositoryExecute(r ApiGetCocoapodsProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetCocoapodsProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cocoapods/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComposerProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetComposerProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetComposerProxyRepositoryExecute(r)
}

/*
GetComposerProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetComposerProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetComposerProxyRepository(ctx context.Context, repositoryName string) ApiGetComposerProxyRepositoryRequest {
	return ApiGetComposerProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetComposerProxyRepositoryExecute(r ApiGetComposerProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetComposerProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/composer/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConanGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetConanGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetConanGroupRepositoryExecute(r)
}

/*
GetConanGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetConanGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetConanGroupRepository(ctx context.Context, repositoryName string) ApiGetConanGroupRepositoryRequest {
	return ApiGetConanGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetConanGroupRepositoryExecute(r ApiGetConanGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetConanGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConanHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetConanHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetConanHostedRepositoryExecute(r)
}

/*
GetConanHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetConanHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetConanHostedRepository(ctx context.Context, repositoryName string) ApiGetConanHostedRepositoryRequest {
	return ApiGetConanHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetConanHostedRepositoryExecute(r ApiGetConanHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetConanHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConanProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetConanProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetConanProxyRepositoryExecute(r)
}

/*
GetConanProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetConanProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetConanProxyRepository(ctx context.Context, repositoryName string) ApiGetConanProxyRepositoryRequest {
	return ApiGetConanProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetConanProxyRepositoryExecute(r ApiGetConanProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetConanProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCondaProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetCondaProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetCondaProxyRepositoryExecute(r)
}

/*
GetCondaProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetCondaProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetCondaProxyRepository(ctx context.Context, repositoryName string) ApiGetCondaProxyRepositoryRequest {
	return ApiGetCondaProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetCondaProxyRepositoryExecute(r ApiGetCondaProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetCondaProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conda/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDockerGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetDockerGroupRepositoryRequest) Execute() (*DockerGroupApiRepository, *http.Response, error) {
	return r.ApiService.GetDockerGroupRepositoryExecute(r)
}

/*
GetDockerGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetDockerGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetDockerGroupRepository(ctx context.Context, repositoryName string) ApiGetDockerGroupRepositoryRequest {
	return ApiGetDockerGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return DockerGroupApiRepository
func (a *RepositoryManagementAPIService) GetDockerGroupRepositoryExecute(r ApiGetDockerGroupRepositoryRequest) (*DockerGroupApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DockerGroupApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetDockerGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDockerHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetDockerHostedRepositoryRequest) Execute() (*DockerHostedApiRepository, *http.Response, error) {
	return r.ApiService.GetDockerHostedRepositoryExecute(r)
}

/*
GetDockerHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetDockerHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetDockerHostedRepository(ctx context.Context, repositoryName string) ApiGetDockerHostedRepositoryRequest {
	return ApiGetDockerHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return DockerHostedApiRepository
func (a *RepositoryManagementAPIService) GetDockerHostedRepositoryExecute(r ApiGetDockerHostedRepositoryRequest) (*DockerHostedApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DockerHostedApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetDockerHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDockerProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetDockerProxyRepositoryRequest) Execute() (*DockerProxyApiRepository, *http.Response, error) {
	return r.ApiService.GetDockerProxyRepositoryExecute(r)
}

/*
GetDockerProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetDockerProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetDockerProxyRepository(ctx context.Context, repositoryName string) ApiGetDockerProxyRepositoryRequest {
	return ApiGetDockerProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return DockerProxyApiRepository
func (a *RepositoryManagementAPIService) GetDockerProxyRepositoryExecute(r ApiGetDockerProxyRepositoryRequest) (*DockerProxyApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DockerProxyApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetDockerProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGitlfsHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetGitlfsHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetGitlfsHostedRepositoryExecute(r)
}

/*
GetGitlfsHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetGitlfsHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetGitlfsHostedRepository(ctx context.Context, repositoryName string) ApiGetGitlfsHostedRepositoryRequest {
	return ApiGetGitlfsHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetGitlfsHostedRepositoryExecute(r ApiGetGitlfsHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetGitlfsHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/gitlfs/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGoGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetGoGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetGoGroupRepositoryExecute(r)
}

/*
GetGoGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetGoGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetGoGroupRepository(ctx context.Context, repositoryName string) ApiGetGoGroupRepositoryRequest {
	return ApiGetGoGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetGoGroupRepositoryExecute(r ApiGetGoGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetGoGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/go/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGoProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetGoProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetGoProxyRepositoryExecute(r)
}

/*
GetGoProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetGoProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetGoProxyRepository(ctx context.Context, repositoryName string) ApiGetGoProxyRepositoryRequest {
	return ApiGetGoProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetGoProxyRepositoryExecute(r ApiGetGoProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetGoProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/go/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHelmHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetHelmHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetHelmHostedRepositoryExecute(r)
}

/*
GetHelmHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetHelmHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetHelmHostedRepository(ctx context.Context, repositoryName string) ApiGetHelmHostedRepositoryRequest {
	return ApiGetHelmHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetHelmHostedRepositoryExecute(r ApiGetHelmHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetHelmHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/helm/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHelmProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetHelmProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetHelmProxyRepositoryExecute(r)
}

/*
GetHelmProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetHelmProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetHelmProxyRepository(ctx context.Context, repositoryName string) ApiGetHelmProxyRepositoryRequest {
	return ApiGetHelmProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetHelmProxyRepositoryExecute(r ApiGetHelmProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetHelmProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/helm/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHuggingfaceProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetHuggingfaceProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetHuggingfaceProxyRepositoryExecute(r)
}

/*
GetHuggingfaceProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetHuggingfaceProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetHuggingfaceProxyRepository(ctx context.Context, repositoryName string) ApiGetHuggingfaceProxyRepositoryRequest {
	return ApiGetHuggingfaceProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetHuggingfaceProxyRepositoryExecute(r ApiGetHuggingfaceProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetHuggingfaceProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/huggingface/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMavenGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetMavenGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetMavenGroupRepositoryExecute(r)
}

/*
GetMavenGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetMavenGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetMavenGroupRepository(ctx context.Context, repositoryName string) ApiGetMavenGroupRepositoryRequest {
	return ApiGetMavenGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetMavenGroupRepositoryExecute(r ApiGetMavenGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetMavenGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMavenHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetMavenHostedRepositoryRequest) Execute() (*MavenHostedApiRepository, *http.Response, error) {
	return r.ApiService.GetMavenHostedRepositoryExecute(r)
}

/*
GetMavenHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetMavenHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetMavenHostedRepository(ctx context.Context, repositoryName string) ApiGetMavenHostedRepositoryRequest {
	return ApiGetMavenHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return MavenHostedApiRepository
func (a *RepositoryManagementAPIService) GetMavenHostedRepositoryExecute(r ApiGetMavenHostedRepositoryRequest) (*MavenHostedApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MavenHostedApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetMavenHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMavenProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetMavenProxyRepositoryRequest) Execute() (*MavenProxyApiRepository, *http.Response, error) {
	return r.ApiService.GetMavenProxyRepositoryExecute(r)
}

/*
GetMavenProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetMavenProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetMavenProxyRepository(ctx context.Context, repositoryName string) ApiGetMavenProxyRepositoryRequest {
	return ApiGetMavenProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return MavenProxyApiRepository
func (a *RepositoryManagementAPIService) GetMavenProxyRepositoryExecute(r ApiGetMavenProxyRepositoryRequest) (*MavenProxyApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MavenProxyApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetMavenProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNpmGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetNpmGroupRepositoryRequest) Execute() (*SimpleApiGroupDeployRepository, *http.Response, error) {
	return r.ApiService.GetNpmGroupRepositoryExecute(r)
}

/*
GetNpmGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetNpmGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetNpmGroupRepository(ctx context.Context, repositoryName string) ApiGetNpmGroupRepositoryRequest {
	return ApiGetNpmGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupDeployRepository
func (a *RepositoryManagementAPIService) GetNpmGroupRepositoryExecute(r ApiGetNpmGroupRepositoryRequest) (*SimpleApiGroupDeployRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupDeployRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetNpmGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNpmHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetNpmHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetNpmHostedRepositoryExecute(r)
}

/*
GetNpmHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetNpmHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetNpmHostedRepository(ctx context.Context, repositoryName string) ApiGetNpmHostedRepositoryRequest {
	return ApiGetNpmHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetNpmHostedRepositoryExecute(r ApiGetNpmHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetNpmHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNpmProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetNpmProxyRepositoryRequest) Execute() (*NpmProxyApiRepository, *http.Response, error) {
	return r.ApiService.GetNpmProxyRepositoryExecute(r)
}

/*
GetNpmProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetNpmProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetNpmProxyRepository(ctx context.Context, repositoryName string) ApiGetNpmProxyRepositoryRequest {
	return ApiGetNpmProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return NpmProxyApiRepository
func (a *RepositoryManagementAPIService) GetNpmProxyRepositoryExecute(r ApiGetNpmProxyRepositoryRequest) (*NpmProxyApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NpmProxyApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetNpmProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNugetGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetNugetGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetNugetGroupRepositoryExecute(r)
}

/*
GetNugetGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetNugetGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetNugetGroupRepository(ctx context.Context, repositoryName string) ApiGetNugetGroupRepositoryRequest {
	return ApiGetNugetGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetNugetGroupRepositoryExecute(r ApiGetNugetGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetNugetGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNugetHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetNugetHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetNugetHostedRepositoryExecute(r)
}

/*
GetNugetHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetNugetHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetNugetHostedRepository(ctx context.Context, repositoryName string) ApiGetNugetHostedRepositoryRequest {
	return ApiGetNugetHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetNugetHostedRepositoryExecute(r ApiGetNugetHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetNugetHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNugetProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetNugetProxyRepositoryRequest) Execute() (*NugetProxyApiRepository, *http.Response, error) {
	return r.ApiService.GetNugetProxyRepositoryExecute(r)
}

/*
GetNugetProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetNugetProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetNugetProxyRepository(ctx context.Context, repositoryName string) ApiGetNugetProxyRepositoryRequest {
	return ApiGetNugetProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return NugetProxyApiRepository
func (a *RepositoryManagementAPIService) GetNugetProxyRepositoryExecute(r ApiGetNugetProxyRepositoryRequest) (*NugetProxyApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NugetProxyApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetNugetProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetP2ProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetP2ProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetP2ProxyRepositoryExecute(r)
}

/*
GetP2ProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetP2ProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetP2ProxyRepository(ctx context.Context, repositoryName string) ApiGetP2ProxyRepositoryRequest {
	return ApiGetP2ProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetP2ProxyRepositoryExecute(r ApiGetP2ProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetP2ProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/p2/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPypiGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetPypiGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetPypiGroupRepositoryExecute(r)
}

/*
GetPypiGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetPypiGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetPypiGroupRepository(ctx context.Context, repositoryName string) ApiGetPypiGroupRepositoryRequest {
	return ApiGetPypiGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetPypiGroupRepositoryExecute(r ApiGetPypiGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetPypiGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPypiHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetPypiHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetPypiHostedRepositoryExecute(r)
}

/*
GetPypiHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetPypiHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetPypiHostedRepository(ctx context.Context, repositoryName string) ApiGetPypiHostedRepositoryRequest {
	return ApiGetPypiHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetPypiHostedRepositoryExecute(r ApiGetPypiHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetPypiHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPypiProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetPypiProxyRepositoryRequest) Execute() (*PypiProxyRepositoryApiRequest, *http.Response, error) {
	return r.ApiService.GetPypiProxyRepositoryExecute(r)
}

/*
GetPypiProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetPypiProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetPypiProxyRepository(ctx context.Context, repositoryName string) ApiGetPypiProxyRepositoryRequest {
	return ApiGetPypiProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return PypiProxyRepositoryApiRequest
func (a *RepositoryManagementAPIService) GetPypiProxyRepositoryExecute(r ApiGetPypiProxyRepositoryRequest) (*PypiProxyRepositoryApiRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PypiProxyRepositoryApiRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetPypiProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetRGroupRepositoryExecute(r)
}

/*
GetRGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRGroupRepository(ctx context.Context, repositoryName string) ApiGetRGroupRepositoryRequest {
	return ApiGetRGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetRGroupRepositoryExecute(r ApiGetRGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetRHostedRepositoryExecute(r)
}

/*
GetRHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRHostedRepository(ctx context.Context, repositoryName string) ApiGetRHostedRepositoryRequest {
	return ApiGetRHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetRHostedRepositoryExecute(r ApiGetRHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetRProxyRepositoryExecute(r)
}

/*
GetRProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRProxyRepository(ctx context.Context, repositoryName string) ApiGetRProxyRepositoryRequest {
	return ApiGetRProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetRProxyRepositoryExecute(r ApiGetRProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRawGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetRawGroupRepositoryExecute(r)
}

/*
GetRawGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRawGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRawGroupRepository(ctx context.Context, repositoryName string) ApiGetRawGroupRepositoryRequest {
	return ApiGetRawGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetRawGroupRepositoryExecute(r ApiGetRawGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRawGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRawHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetRawHostedRepositoryExecute(r)
}

/*
GetRawHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRawHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRawHostedRepository(ctx context.Context, repositoryName string) ApiGetRawHostedRepositoryRequest {
	return ApiGetRawHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetRawHostedRepositoryExecute(r ApiGetRawHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRawHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRawProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetRawProxyRepositoryExecute(r)
}

/*
GetRawProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRawProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRawProxyRepository(ctx context.Context, repositoryName string) ApiGetRawProxyRepositoryRequest {
	return ApiGetRawProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetRawProxyRepositoryExecute(r ApiGetRawProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRawProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoriesRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
}

func (r ApiGetRepositoriesRequest) Execute() ([]AbstractApiRepository, *http.Response, error) {
	return r.ApiService.GetRepositoriesExecute(r)
}

/*
GetRepositories List repositories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRepositoriesRequest
*/
func (a *RepositoryManagementAPIService) GetRepositories(ctx context.Context) ApiGetRepositoriesRequest {
	return ApiGetRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AbstractApiRepository
func (a *RepositoryManagementAPIService) GetRepositoriesExecute(r ApiGetRepositoriesRequest) ([]AbstractApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AbstractApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRepositories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositorySettings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRepositoryRequest) Execute() (*RepositoryXO, *http.Response, error) {
	return r.ApiService.GetRepositoryExecute(r)
}

/*
GetRepository Get repository details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to get
 @return ApiGetRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRepository(ctx context.Context, repositoryName string) ApiGetRepositoryRequest {
	return ApiGetRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return RepositoryXO
func (a *RepositoryManagementAPIService) GetRepositoryExecute(r ApiGetRepositoryRequest) (*RepositoryXO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepositoryXO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubygemsGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRubygemsGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetRubygemsGroupRepositoryExecute(r)
}

/*
GetRubygemsGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRubygemsGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRubygemsGroupRepository(ctx context.Context, repositoryName string) ApiGetRubygemsGroupRepositoryRequest {
	return ApiGetRubygemsGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetRubygemsGroupRepositoryExecute(r ApiGetRubygemsGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRubygemsGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubygemsHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRubygemsHostedRepositoryRequest) Execute() (*SimpleApiHostedRepository, *http.Response, error) {
	return r.ApiService.GetRubygemsHostedRepositoryExecute(r)
}

/*
GetRubygemsHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRubygemsHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRubygemsHostedRepository(ctx context.Context, repositoryName string) ApiGetRubygemsHostedRepositoryRequest {
	return ApiGetRubygemsHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiHostedRepository
func (a *RepositoryManagementAPIService) GetRubygemsHostedRepositoryExecute(r ApiGetRubygemsHostedRepositoryRequest) (*SimpleApiHostedRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiHostedRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRubygemsHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRubygemsProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetRubygemsProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetRubygemsProxyRepositoryExecute(r)
}

/*
GetRubygemsProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetRubygemsProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetRubygemsProxyRepository(ctx context.Context, repositoryName string) ApiGetRubygemsProxyRepositoryRequest {
	return ApiGetRubygemsProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetRubygemsProxyRepositoryExecute(r ApiGetRubygemsProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetRubygemsProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetYumGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetYumGroupRepositoryRequest) Execute() (*SimpleApiGroupRepository, *http.Response, error) {
	return r.ApiService.GetYumGroupRepositoryExecute(r)
}

/*
GetYumGroupRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetYumGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetYumGroupRepository(ctx context.Context, repositoryName string) ApiGetYumGroupRepositoryRequest {
	return ApiGetYumGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiGroupRepository
func (a *RepositoryManagementAPIService) GetYumGroupRepositoryExecute(r ApiGetYumGroupRepositoryRequest) (*SimpleApiGroupRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiGroupRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetYumGroupRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetYumHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetYumHostedRepositoryRequest) Execute() (*YumHostedApiRepository, *http.Response, error) {
	return r.ApiService.GetYumHostedRepositoryExecute(r)
}

/*
GetYumHostedRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetYumHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetYumHostedRepository(ctx context.Context, repositoryName string) ApiGetYumHostedRepositoryRequest {
	return ApiGetYumHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return YumHostedApiRepository
func (a *RepositoryManagementAPIService) GetYumHostedRepositoryExecute(r ApiGetYumHostedRepositoryRequest) (*YumHostedApiRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YumHostedApiRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetYumHostedRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetYumProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
}

func (r ApiGetYumProxyRepositoryRequest) Execute() (*SimpleApiProxyRepository, *http.Response, error) {
	return r.ApiService.GetYumProxyRepositoryExecute(r)
}

/*
GetYumProxyRepository Get repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName
 @return ApiGetYumProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) GetYumProxyRepository(ctx context.Context, repositoryName string) ApiGetYumProxyRepositoryRequest {
	return ApiGetYumProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
//  @return SimpleApiProxyRepository
func (a *RepositoryManagementAPIService) GetYumProxyRepositoryExecute(r ApiGetYumProxyRepositoryRequest) (*SimpleApiProxyRepository, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleApiProxyRepository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.GetYumProxyRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAptHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *AptHostedRepositoryApiRequest
}

func (r ApiUpdateAptHostedRepositoryRequest) Body(body AptHostedRepositoryApiRequest) ApiUpdateAptHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAptHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAptHostedRepositoryExecute(r)
}

/*
UpdateAptHostedRepository Update APT hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateAptHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateAptHostedRepository(ctx context.Context, repositoryName string) ApiUpdateAptHostedRepositoryRequest {
	return ApiUpdateAptHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateAptHostedRepositoryExecute(r ApiUpdateAptHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateAptHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/apt/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAptProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *AptProxyRepositoryApiRequest
}

func (r ApiUpdateAptProxyRepositoryRequest) Body(body AptProxyRepositoryApiRequest) ApiUpdateAptProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAptProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAptProxyRepositoryExecute(r)
}

/*
UpdateAptProxyRepository Update APT proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateAptProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateAptProxyRepository(ctx context.Context, repositoryName string) ApiUpdateAptProxyRepositoryRequest {
	return ApiUpdateAptProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateAptProxyRepositoryExecute(r ApiUpdateAptProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateAptProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/apt/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCargoGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *CargoGroupRepositoryApiRequest
}

func (r ApiUpdateCargoGroupRepositoryRequest) Body(body CargoGroupRepositoryApiRequest) ApiUpdateCargoGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCargoGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCargoGroupRepositoryExecute(r)
}

/*
UpdateCargoGroupRepository Update cargo group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateCargoGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateCargoGroupRepository(ctx context.Context, repositoryName string) ApiUpdateCargoGroupRepositoryRequest {
	return ApiUpdateCargoGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateCargoGroupRepositoryExecute(r ApiUpdateCargoGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateCargoGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCargoHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *CargoHostedRepositoryApiRequest
}

func (r ApiUpdateCargoHostedRepositoryRequest) Body(body CargoHostedRepositoryApiRequest) ApiUpdateCargoHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCargoHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCargoHostedRepositoryExecute(r)
}

/*
UpdateCargoHostedRepository Update cargo hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateCargoHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateCargoHostedRepository(ctx context.Context, repositoryName string) ApiUpdateCargoHostedRepositoryRequest {
	return ApiUpdateCargoHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateCargoHostedRepositoryExecute(r ApiUpdateCargoHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateCargoHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCargoProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *CargoProxyRepositoryApiRequest
}

func (r ApiUpdateCargoProxyRepositoryRequest) Body(body CargoProxyRepositoryApiRequest) ApiUpdateCargoProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCargoProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCargoProxyRepositoryExecute(r)
}

/*
UpdateCargoProxyRepository Update cargo proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateCargoProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateCargoProxyRepository(ctx context.Context, repositoryName string) ApiUpdateCargoProxyRepositoryRequest {
	return ApiUpdateCargoProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateCargoProxyRepositoryExecute(r ApiUpdateCargoProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateCargoProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cargo/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCocoapodsProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *CocoapodsProxyRepositoryApiRequest
}

func (r ApiUpdateCocoapodsProxyRepositoryRequest) Body(body CocoapodsProxyRepositoryApiRequest) ApiUpdateCocoapodsProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCocoapodsProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCocoapodsProxyRepositoryExecute(r)
}

/*
UpdateCocoapodsProxyRepository Update Cocoapods proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateCocoapodsProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateCocoapodsProxyRepository(ctx context.Context, repositoryName string) ApiUpdateCocoapodsProxyRepositoryRequest {
	return ApiUpdateCocoapodsProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateCocoapodsProxyRepositoryExecute(r ApiUpdateCocoapodsProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateCocoapodsProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/cocoapods/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateComposerProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *ComposerProxyRepositoryApiRequest
}

func (r ApiUpdateComposerProxyRepositoryRequest) Body(body ComposerProxyRepositoryApiRequest) ApiUpdateComposerProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateComposerProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateComposerProxyRepositoryExecute(r)
}

/*
UpdateComposerProxyRepository Update composer proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateComposerProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateComposerProxyRepository(ctx context.Context, repositoryName string) ApiUpdateComposerProxyRepositoryRequest {
	return ApiUpdateComposerProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateComposerProxyRepositoryExecute(r ApiUpdateComposerProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateComposerProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/composer/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateConanGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *ConanGroupRepositoryApiRequest
}

func (r ApiUpdateConanGroupRepositoryRequest) Body(body ConanGroupRepositoryApiRequest) ApiUpdateConanGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateConanGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateConanGroupRepositoryExecute(r)
}

/*
UpdateConanGroupRepository Update Conan group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateConanGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateConanGroupRepository(ctx context.Context, repositoryName string) ApiUpdateConanGroupRepositoryRequest {
	return ApiUpdateConanGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateConanGroupRepositoryExecute(r ApiUpdateConanGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateConanGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateConanHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *ConanHostedRepositoryApiRequest
}

func (r ApiUpdateConanHostedRepositoryRequest) Body(body ConanHostedRepositoryApiRequest) ApiUpdateConanHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateConanHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateConanHostedRepositoryExecute(r)
}

/*
UpdateConanHostedRepository Update Conan hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateConanHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateConanHostedRepository(ctx context.Context, repositoryName string) ApiUpdateConanHostedRepositoryRequest {
	return ApiUpdateConanHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateConanHostedRepositoryExecute(r ApiUpdateConanHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateConanHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateConanProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *ConanProxyRepositoryApiRequest
}

func (r ApiUpdateConanProxyRepositoryRequest) Body(body ConanProxyRepositoryApiRequest) ApiUpdateConanProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateConanProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateConanProxyRepositoryExecute(r)
}

/*
UpdateConanProxyRepository Update Conan proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateConanProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateConanProxyRepository(ctx context.Context, repositoryName string) ApiUpdateConanProxyRepositoryRequest {
	return ApiUpdateConanProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateConanProxyRepositoryExecute(r ApiUpdateConanProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateConanProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conan/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCondaProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *CondaProxyRepositoryApiRequest
}

func (r ApiUpdateCondaProxyRepositoryRequest) Body(body CondaProxyRepositoryApiRequest) ApiUpdateCondaProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCondaProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCondaProxyRepositoryExecute(r)
}

/*
UpdateCondaProxyRepository Update conda proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateCondaProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateCondaProxyRepository(ctx context.Context, repositoryName string) ApiUpdateCondaProxyRepositoryRequest {
	return ApiUpdateCondaProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateCondaProxyRepositoryExecute(r ApiUpdateCondaProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateCondaProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/conda/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDockerGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *DockerGroupRepositoryApiRequest
}

func (r ApiUpdateDockerGroupRepositoryRequest) Body(body DockerGroupRepositoryApiRequest) ApiUpdateDockerGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateDockerGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDockerGroupRepositoryExecute(r)
}

/*
UpdateDockerGroupRepository Update Docker group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateDockerGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateDockerGroupRepository(ctx context.Context, repositoryName string) ApiUpdateDockerGroupRepositoryRequest {
	return ApiUpdateDockerGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateDockerGroupRepositoryExecute(r ApiUpdateDockerGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateDockerGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDockerHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *DockerHostedRepositoryApiRequest
}

func (r ApiUpdateDockerHostedRepositoryRequest) Body(body DockerHostedRepositoryApiRequest) ApiUpdateDockerHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateDockerHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDockerHostedRepositoryExecute(r)
}

/*
UpdateDockerHostedRepository Update Docker hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateDockerHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateDockerHostedRepository(ctx context.Context, repositoryName string) ApiUpdateDockerHostedRepositoryRequest {
	return ApiUpdateDockerHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateDockerHostedRepositoryExecute(r ApiUpdateDockerHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateDockerHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDockerProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *DockerProxyRepositoryApiRequest
}

func (r ApiUpdateDockerProxyRepositoryRequest) Body(body DockerProxyRepositoryApiRequest) ApiUpdateDockerProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateDockerProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDockerProxyRepositoryExecute(r)
}

/*
UpdateDockerProxyRepository Update Docker proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateDockerProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateDockerProxyRepository(ctx context.Context, repositoryName string) ApiUpdateDockerProxyRepositoryRequest {
	return ApiUpdateDockerProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateDockerProxyRepositoryExecute(r ApiUpdateDockerProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateDockerProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/docker/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateGitlfsHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *GitLfsHostedRepositoryApiRequest
}

func (r ApiUpdateGitlfsHostedRepositoryRequest) Body(body GitLfsHostedRepositoryApiRequest) ApiUpdateGitlfsHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateGitlfsHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGitlfsHostedRepositoryExecute(r)
}

/*
UpdateGitlfsHostedRepository Update Git LFS hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateGitlfsHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateGitlfsHostedRepository(ctx context.Context, repositoryName string) ApiUpdateGitlfsHostedRepositoryRequest {
	return ApiUpdateGitlfsHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateGitlfsHostedRepositoryExecute(r ApiUpdateGitlfsHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateGitlfsHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/gitlfs/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateGoGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *GolangGroupRepositoryApiRequest
}

func (r ApiUpdateGoGroupRepositoryRequest) Body(body GolangGroupRepositoryApiRequest) ApiUpdateGoGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateGoGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGoGroupRepositoryExecute(r)
}

/*
UpdateGoGroupRepository Update a Go group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateGoGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateGoGroupRepository(ctx context.Context, repositoryName string) ApiUpdateGoGroupRepositoryRequest {
	return ApiUpdateGoGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateGoGroupRepositoryExecute(r ApiUpdateGoGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateGoGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/go/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateGoProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *GolangProxyRepositoryApiRequest
}

func (r ApiUpdateGoProxyRepositoryRequest) Body(body GolangProxyRepositoryApiRequest) ApiUpdateGoProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateGoProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGoProxyRepositoryExecute(r)
}

/*
UpdateGoProxyRepository Update a Go proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateGoProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateGoProxyRepository(ctx context.Context, repositoryName string) ApiUpdateGoProxyRepositoryRequest {
	return ApiUpdateGoProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateGoProxyRepositoryExecute(r ApiUpdateGoProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateGoProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/go/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHelmHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *HelmHostedRepositoryApiRequest
}

func (r ApiUpdateHelmHostedRepositoryRequest) Body(body HelmHostedRepositoryApiRequest) ApiUpdateHelmHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateHelmHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHelmHostedRepositoryExecute(r)
}

/*
UpdateHelmHostedRepository Update Helm hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateHelmHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateHelmHostedRepository(ctx context.Context, repositoryName string) ApiUpdateHelmHostedRepositoryRequest {
	return ApiUpdateHelmHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateHelmHostedRepositoryExecute(r ApiUpdateHelmHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateHelmHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/helm/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHelmProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *HelmProxyRepositoryApiRequest
}

func (r ApiUpdateHelmProxyRepositoryRequest) Body(body HelmProxyRepositoryApiRequest) ApiUpdateHelmProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateHelmProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHelmProxyRepositoryExecute(r)
}

/*
UpdateHelmProxyRepository Update Helm proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateHelmProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateHelmProxyRepository(ctx context.Context, repositoryName string) ApiUpdateHelmProxyRepositoryRequest {
	return ApiUpdateHelmProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateHelmProxyRepositoryExecute(r ApiUpdateHelmProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateHelmProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/helm/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHuggingfaceProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *HuggingFaceProxyRepositoryApiRequest
}

func (r ApiUpdateHuggingfaceProxyRepositoryRequest) Body(body HuggingFaceProxyRepositoryApiRequest) ApiUpdateHuggingfaceProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateHuggingfaceProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHuggingfaceProxyRepositoryExecute(r)
}

/*
UpdateHuggingfaceProxyRepository Update huggingface proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateHuggingfaceProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateHuggingfaceProxyRepository(ctx context.Context, repositoryName string) ApiUpdateHuggingfaceProxyRepositoryRequest {
	return ApiUpdateHuggingfaceProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateHuggingfaceProxyRepositoryExecute(r ApiUpdateHuggingfaceProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateHuggingfaceProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/huggingface/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateMavenGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *MavenGroupRepositoryApiRequest
}

func (r ApiUpdateMavenGroupRepositoryRequest) Body(body MavenGroupRepositoryApiRequest) ApiUpdateMavenGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateMavenGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateMavenGroupRepositoryExecute(r)
}

/*
UpdateMavenGroupRepository Update Maven group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateMavenGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateMavenGroupRepository(ctx context.Context, repositoryName string) ApiUpdateMavenGroupRepositoryRequest {
	return ApiUpdateMavenGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateMavenGroupRepositoryExecute(r ApiUpdateMavenGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateMavenGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateMavenHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *MavenHostedRepositoryApiRequest
}

func (r ApiUpdateMavenHostedRepositoryRequest) Body(body MavenHostedRepositoryApiRequest) ApiUpdateMavenHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateMavenHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateMavenHostedRepositoryExecute(r)
}

/*
UpdateMavenHostedRepository Update Maven hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateMavenHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateMavenHostedRepository(ctx context.Context, repositoryName string) ApiUpdateMavenHostedRepositoryRequest {
	return ApiUpdateMavenHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateMavenHostedRepositoryExecute(r ApiUpdateMavenHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateMavenHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateMavenProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *MavenProxyRepositoryApiRequest
}

func (r ApiUpdateMavenProxyRepositoryRequest) Body(body MavenProxyRepositoryApiRequest) ApiUpdateMavenProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateMavenProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateMavenProxyRepositoryExecute(r)
}

/*
UpdateMavenProxyRepository Update Maven proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateMavenProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateMavenProxyRepository(ctx context.Context, repositoryName string) ApiUpdateMavenProxyRepositoryRequest {
	return ApiUpdateMavenProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateMavenProxyRepositoryExecute(r ApiUpdateMavenProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateMavenProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/maven/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNpmGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *NpmGroupRepositoryApiRequest
}

func (r ApiUpdateNpmGroupRepositoryRequest) Body(body NpmGroupRepositoryApiRequest) ApiUpdateNpmGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNpmGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateNpmGroupRepositoryExecute(r)
}

/*
UpdateNpmGroupRepository Update npm group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateNpmGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateNpmGroupRepository(ctx context.Context, repositoryName string) ApiUpdateNpmGroupRepositoryRequest {
	return ApiUpdateNpmGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateNpmGroupRepositoryExecute(r ApiUpdateNpmGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateNpmGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNpmHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *NpmHostedRepositoryApiRequest
}

func (r ApiUpdateNpmHostedRepositoryRequest) Body(body NpmHostedRepositoryApiRequest) ApiUpdateNpmHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNpmHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateNpmHostedRepositoryExecute(r)
}

/*
UpdateNpmHostedRepository Update npm hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateNpmHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateNpmHostedRepository(ctx context.Context, repositoryName string) ApiUpdateNpmHostedRepositoryRequest {
	return ApiUpdateNpmHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateNpmHostedRepositoryExecute(r ApiUpdateNpmHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateNpmHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNpmProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *NpmProxyRepositoryApiRequest
}

func (r ApiUpdateNpmProxyRepositoryRequest) Body(body NpmProxyRepositoryApiRequest) ApiUpdateNpmProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNpmProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateNpmProxyRepositoryExecute(r)
}

/*
UpdateNpmProxyRepository Update npm proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateNpmProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateNpmProxyRepository(ctx context.Context, repositoryName string) ApiUpdateNpmProxyRepositoryRequest {
	return ApiUpdateNpmProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateNpmProxyRepositoryExecute(r ApiUpdateNpmProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateNpmProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/npm/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNugetGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *NugetGroupRepositoryApiRequest
}

func (r ApiUpdateNugetGroupRepositoryRequest) Body(body NugetGroupRepositoryApiRequest) ApiUpdateNugetGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNugetGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateNugetGroupRepositoryExecute(r)
}

/*
UpdateNugetGroupRepository Update NuGet group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateNugetGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateNugetGroupRepository(ctx context.Context, repositoryName string) ApiUpdateNugetGroupRepositoryRequest {
	return ApiUpdateNugetGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateNugetGroupRepositoryExecute(r ApiUpdateNugetGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateNugetGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNugetHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *NugetHostedRepositoryApiRequest
}

func (r ApiUpdateNugetHostedRepositoryRequest) Body(body NugetHostedRepositoryApiRequest) ApiUpdateNugetHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNugetHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateNugetHostedRepositoryExecute(r)
}

/*
UpdateNugetHostedRepository Update NuGet hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateNugetHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateNugetHostedRepository(ctx context.Context, repositoryName string) ApiUpdateNugetHostedRepositoryRequest {
	return ApiUpdateNugetHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateNugetHostedRepositoryExecute(r ApiUpdateNugetHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateNugetHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNugetProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *NugetProxyRepositoryApiRequest
}

func (r ApiUpdateNugetProxyRepositoryRequest) Body(body NugetProxyRepositoryApiRequest) ApiUpdateNugetProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNugetProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateNugetProxyRepositoryExecute(r)
}

/*
UpdateNugetProxyRepository Update NuGet proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateNugetProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateNugetProxyRepository(ctx context.Context, repositoryName string) ApiUpdateNugetProxyRepositoryRequest {
	return ApiUpdateNugetProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateNugetProxyRepositoryExecute(r ApiUpdateNugetProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateNugetProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/nuget/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateP2ProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *P2ProxyRepositoryApiRequest
}

func (r ApiUpdateP2ProxyRepositoryRequest) Body(body P2ProxyRepositoryApiRequest) ApiUpdateP2ProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateP2ProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateP2ProxyRepositoryExecute(r)
}

/*
UpdateP2ProxyRepository Update p2 proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateP2ProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateP2ProxyRepository(ctx context.Context, repositoryName string) ApiUpdateP2ProxyRepositoryRequest {
	return ApiUpdateP2ProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateP2ProxyRepositoryExecute(r ApiUpdateP2ProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateP2ProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/p2/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdatePypiGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *PypiGroupRepositoryApiRequest
}

func (r ApiUpdatePypiGroupRepositoryRequest) Body(body PypiGroupRepositoryApiRequest) ApiUpdatePypiGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdatePypiGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePypiGroupRepositoryExecute(r)
}

/*
UpdatePypiGroupRepository Update PyPI group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdatePypiGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdatePypiGroupRepository(ctx context.Context, repositoryName string) ApiUpdatePypiGroupRepositoryRequest {
	return ApiUpdatePypiGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdatePypiGroupRepositoryExecute(r ApiUpdatePypiGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdatePypiGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdatePypiHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *PypiHostedRepositoryApiRequest
}

func (r ApiUpdatePypiHostedRepositoryRequest) Body(body PypiHostedRepositoryApiRequest) ApiUpdatePypiHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdatePypiHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePypiHostedRepositoryExecute(r)
}

/*
UpdatePypiHostedRepository Update PyPI hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdatePypiHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdatePypiHostedRepository(ctx context.Context, repositoryName string) ApiUpdatePypiHostedRepositoryRequest {
	return ApiUpdatePypiHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdatePypiHostedRepositoryExecute(r ApiUpdatePypiHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdatePypiHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdatePypiProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *PypiProxyRepositoryApiRequest
}

func (r ApiUpdatePypiProxyRepositoryRequest) Body(body PypiProxyRepositoryApiRequest) ApiUpdatePypiProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdatePypiProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatePypiProxyRepositoryExecute(r)
}

/*
UpdatePypiProxyRepository Update PyPI proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdatePypiProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdatePypiProxyRepository(ctx context.Context, repositoryName string) ApiUpdatePypiProxyRepositoryRequest {
	return ApiUpdatePypiProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdatePypiProxyRepositoryExecute(r ApiUpdatePypiProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdatePypiProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/pypi/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RGroupRepositoryApiRequest
}

func (r ApiUpdateRGroupRepositoryRequest) Body(body RGroupRepositoryApiRequest) ApiUpdateRGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRGroupRepositoryExecute(r)
}

/*
UpdateRGroupRepository Update R group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRGroupRepository(ctx context.Context, repositoryName string) ApiUpdateRGroupRepositoryRequest {
	return ApiUpdateRGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRGroupRepositoryExecute(r ApiUpdateRGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RHostedRepositoryApiRequest
}

func (r ApiUpdateRHostedRepositoryRequest) Body(body RHostedRepositoryApiRequest) ApiUpdateRHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRHostedRepositoryExecute(r)
}

/*
UpdateRHostedRepository Update R hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRHostedRepository(ctx context.Context, repositoryName string) ApiUpdateRHostedRepositoryRequest {
	return ApiUpdateRHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRHostedRepositoryExecute(r ApiUpdateRHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RProxyRepositoryApiRequest
}

func (r ApiUpdateRProxyRepositoryRequest) Body(body RProxyRepositoryApiRequest) ApiUpdateRProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRProxyRepositoryExecute(r)
}

/*
UpdateRProxyRepository Update R proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRProxyRepository(ctx context.Context, repositoryName string) ApiUpdateRProxyRepositoryRequest {
	return ApiUpdateRProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRProxyRepositoryExecute(r ApiUpdateRProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/r/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRawGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RawGroupRepositoryApiRequest
}

func (r ApiUpdateRawGroupRepositoryRequest) Body(body RawGroupRepositoryApiRequest) ApiUpdateRawGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRawGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRawGroupRepositoryExecute(r)
}

/*
UpdateRawGroupRepository Update raw group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRawGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRawGroupRepository(ctx context.Context, repositoryName string) ApiUpdateRawGroupRepositoryRequest {
	return ApiUpdateRawGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRawGroupRepositoryExecute(r ApiUpdateRawGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRawGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRawHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RawHostedRepositoryApiRequest
}

func (r ApiUpdateRawHostedRepositoryRequest) Body(body RawHostedRepositoryApiRequest) ApiUpdateRawHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRawHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRawHostedRepositoryExecute(r)
}

/*
UpdateRawHostedRepository Update raw hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRawHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRawHostedRepository(ctx context.Context, repositoryName string) ApiUpdateRawHostedRepositoryRequest {
	return ApiUpdateRawHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRawHostedRepositoryExecute(r ApiUpdateRawHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRawHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRawProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RawProxyRepositoryApiRequest
}

func (r ApiUpdateRawProxyRepositoryRequest) Body(body RawProxyRepositoryApiRequest) ApiUpdateRawProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRawProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRawProxyRepositoryExecute(r)
}

/*
UpdateRawProxyRepository Update raw proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRawProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRawProxyRepository(ctx context.Context, repositoryName string) ApiUpdateRawProxyRepositoryRequest {
	return ApiUpdateRawProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRawProxyRepositoryExecute(r ApiUpdateRawProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRawProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/raw/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRubygemsGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RubyGemsGroupRepositoryApiRequest
}

func (r ApiUpdateRubygemsGroupRepositoryRequest) Body(body RubyGemsGroupRepositoryApiRequest) ApiUpdateRubygemsGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRubygemsGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRubygemsGroupRepositoryExecute(r)
}

/*
UpdateRubygemsGroupRepository Update RubyGems group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRubygemsGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRubygemsGroupRepository(ctx context.Context, repositoryName string) ApiUpdateRubygemsGroupRepositoryRequest {
	return ApiUpdateRubygemsGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRubygemsGroupRepositoryExecute(r ApiUpdateRubygemsGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRubygemsGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRubygemsHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RubyGemsHostedRepositoryApiRequest
}

func (r ApiUpdateRubygemsHostedRepositoryRequest) Body(body RubyGemsHostedRepositoryApiRequest) ApiUpdateRubygemsHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRubygemsHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRubygemsHostedRepositoryExecute(r)
}

/*
UpdateRubygemsHostedRepository Update RubyGems hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRubygemsHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRubygemsHostedRepository(ctx context.Context, repositoryName string) ApiUpdateRubygemsHostedRepositoryRequest {
	return ApiUpdateRubygemsHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRubygemsHostedRepositoryExecute(r ApiUpdateRubygemsHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRubygemsHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRubygemsProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *RubyGemsProxyRepositoryApiRequest
}

func (r ApiUpdateRubygemsProxyRepositoryRequest) Body(body RubyGemsProxyRepositoryApiRequest) ApiUpdateRubygemsProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRubygemsProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRubygemsProxyRepositoryExecute(r)
}

/*
UpdateRubygemsProxyRepository Update RubyGems proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateRubygemsProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateRubygemsProxyRepository(ctx context.Context, repositoryName string) ApiUpdateRubygemsProxyRepositoryRequest {
	return ApiUpdateRubygemsProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateRubygemsProxyRepositoryExecute(r ApiUpdateRubygemsProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateRubygemsProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/rubygems/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateYumGroupRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *YumGroupRepositoryApiRequest
}

func (r ApiUpdateYumGroupRepositoryRequest) Body(body YumGroupRepositoryApiRequest) ApiUpdateYumGroupRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateYumGroupRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateYumGroupRepositoryExecute(r)
}

/*
UpdateYumGroupRepository Update Yum group repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateYumGroupRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateYumGroupRepository(ctx context.Context, repositoryName string) ApiUpdateYumGroupRepositoryRequest {
	return ApiUpdateYumGroupRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateYumGroupRepositoryExecute(r ApiUpdateYumGroupRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateYumGroupRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/group/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateYumHostedRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *YumHostedRepositoryApiRequest
}

func (r ApiUpdateYumHostedRepositoryRequest) Body(body YumHostedRepositoryApiRequest) ApiUpdateYumHostedRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateYumHostedRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateYumHostedRepositoryExecute(r)
}

/*
UpdateYumHostedRepository Update Yum hosted repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateYumHostedRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateYumHostedRepository(ctx context.Context, repositoryName string) ApiUpdateYumHostedRepositoryRequest {
	return ApiUpdateYumHostedRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateYumHostedRepositoryExecute(r ApiUpdateYumHostedRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateYumHostedRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/hosted/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateYumProxyRepositoryRequest struct {
	ctx context.Context
	ApiService *RepositoryManagementAPIService
	repositoryName string
	body *YumProxyRepositoryApiRequest
}

func (r ApiUpdateYumProxyRepositoryRequest) Body(body YumProxyRepositoryApiRequest) ApiUpdateYumProxyRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateYumProxyRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateYumProxyRepositoryExecute(r)
}

/*
UpdateYumProxyRepository Update Yum proxy repository

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repositoryName Name of the repository to update
 @return ApiUpdateYumProxyRepositoryRequest
*/
func (a *RepositoryManagementAPIService) UpdateYumProxyRepository(ctx context.Context, repositoryName string) ApiUpdateYumProxyRepositoryRequest {
	return ApiUpdateYumProxyRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repositoryName: repositoryName,
	}
}

// Execute executes the request
func (a *RepositoryManagementAPIService) UpdateYumProxyRepositoryExecute(r ApiUpdateYumProxyRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryManagementAPIService.UpdateYumProxyRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/repositories/yum/proxy/{repositoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"repositoryName"+"}", url.PathEscape(parameterValueToString(r.repositoryName, "repositoryName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
